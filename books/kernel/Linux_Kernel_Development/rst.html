<h1 id="linux-kernel-development">Linux Kernel Development</h1>
<dl>
<dt>Author</dt>
<dd><p>whiothes</p>
</dd>
</dl>
<p></p>
<p></p>
<p></p>
<p></p>
<h2 id="linux-kernel-development-1">Linux Kernel Development</h2>
<h3 id="getting-started-with-the-kernel">2 Getting Started with the kernel</h3>
<h4 id="a-beast-of-a-different-nature">A beast of a Different Nature</h4>
<ol>
<li><p>GNU C</p>
<ol>
<li><p>Inline Functions</p>
<p>inserted inline into each function call site. optimize both the caller and the called function as one. code size increased because the contents copied into the callers, increases memory consumption and instruction cache footprint.</p>
<p>Kernel developers use inline functions for small time-critical functions.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> wolf<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> tail_size<span class="op">);</span></span></code></pre></div></li>
</ol></li>
<li><p>No Memory Protection</p>
<p>user-space allication attempts an illegal memory access, the kernel can trap the error, send the SIGSEGV signal, and kill the process. If the kernel attempts an illegal memory access, the results are less controlled.</p></li>
<li><p>No (Easy) Use of Floating Point</p>
<p>when a user-space process uses floating-point instructions, the kernel manages the transition from integer to floating point mode.</p>
<p>Using a floating point inside the kernel requires manually saving and restoring the floating point registers ( DON'T DO IT !)</p></li>
<li><p>Small, Fixed-Size Stack</p>
<p>The kernel stack is neither large nor dynamic; it is small and fixed in size. On x86, the stack size can be either 4KB or 8KB. is two pages, 8KB on 32-bit architectures and 16KB on 64-bit architectures.</p></li>
<li><p>Synchronixation and Concurrency</p></li>
</ol>
<h3 id="process-management">3 Process Management</h3>
<h4 id="the-process">The Process</h4>
<p>process includes: a set of resources such as open files and pending signals, inter kernal data, processor state, a memory address space with one or more memory mappings, one or more threads of execution, and a data section containing global variables.</p>
<p>thread includes a unique program counter, process stack, and sets of processor registers.</p>
<p>kernel schedules individual threads, not process.</p>
<ul>
<li>virtualized processor : process alone monopolizes the system</li>
<li>virtualized memory: allocate and manage memory as if process owned all the memory in the system.</li>
</ul>
<p>threads share the virtual memory abstraction.</p>
<p>a program itself is not a process; a process is an <strong>active</strong> program and related resources.</p>
<h4 id="process-descriptor-and-the-task-structure">Process Descriptor and the Task Structure</h4>
<p>The kernel stores the list of processes in a circular doubly linked list called <em>task list</em>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;linux/sched.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * contains all the information that kernel has and needs about a process</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">volatile</span> <span class="dt">long</span> state<span class="op">;</span> <span class="co">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="op">*</span>        stack<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        atomic_t      usage<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  flags<span class="op">;</span> <span class="co">/* per process flags, defined below */</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  ptrace<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> lock_depth<span class="op">;</span> <span class="co">/* BKL lock depth */</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_SMP</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __ARCH_WANT_UNLOCKED_CTXSW</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> oncpu<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>                       prio<span class="op">,</span> static_prio<span class="op">,</span> normal_prio<span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>              rt_priority<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">const</span> <span class="kw">struct</span> sched_class <span class="op">*</span>sched_class<span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_entity       se<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_rt_entity    rt<span class="op">;</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_PREEMPT_NOTIFIERS</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* list of struct preempt_notifier: */</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> hlist_head preempt_notifiers<span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co">         * fpu_counter contains the number of consecutive context switches</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co">         * that the FPU is used. If this is over a threshold, the lazy fpu</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co">         * saving becomes unlazy to save the trap. This is an unsigned char</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">         * so that after 256 times the counter wraps and the behavior turns</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co">         * lazy again; this to deal with bursty apps that only use FPU for</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="co">         * a short time</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">char</span> fpu_counter<span class="op">;</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_BLK_DEV_IO_TRACE</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> btrace_seq<span class="op">;</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> policy<span class="op">;</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        cpumask_t    cpus_allowed<span class="op">;</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_PREEMPT_RCU</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              rcu_read_lock_nesting<span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>             rcu_read_unlock_special<span class="op">;</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head rcu_node_entry<span class="op">;</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif </span><span class="co">/* #ifdef CONFIG_PREEMPT_RCU */</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_TREE_PREEMPT_RCU</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> rcu_node <span class="op">*</span>rcu_blocked_node<span class="op">;</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif </span><span class="co">/* #ifdef CONFIG_TREE_PREEMPT_RCU */</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_RCU_BOOST</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> rt_mutex <span class="op">*</span>rcu_boost_mutex<span class="op">;</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif </span><span class="co">/* #ifdef CONFIG_RCU_BOOST */</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_info sched_info<span class="op">;</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head tasks<span class="op">;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_SMP</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> plist_node pushable_tasks<span class="op">;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> mm_struct <span class="op">*</span>mm<span class="op">,</span> <span class="op">*</span>active_mm<span class="op">;</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_COMPAT_BRK</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> brk_randomized <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined(SPLIT_RSS_COUNTING)</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_rss_stat rss_stat<span class="op">;</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* task state */</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exit_state<span class="op">;</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exit_code<span class="op">,</span> exit_signal<span class="op">;</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pdeath_signal<span class="op">;</span> <span class="co">/*  The signal sent when the parent dies  */</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* ??? */</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> personality<span class="op">;</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span>     did_exec <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span>     in_execve <span class="op">:</span> <span class="dv">1</span><span class="op">;</span> <span class="co">/* Tell the LSMs that the process is doing an</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a><span class="co">                                     * execve */</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> in_iowait <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Revert to default priority/policy when forking */</span></span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> sched_reset_on_fork <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>        pid_t pid<span class="op">;</span></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>        pid_t tgid<span class="op">;</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_CC_STACKPROTECTOR</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Canary value for the -fstack-protector gcc feature */</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> stack_canary<span class="op">;</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a><span class="co">         * pointers to (original) parent process, youngest child, younger sibling,</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a><span class="co">         * older sibling, respectively.  (p-&gt;father can be replaced with</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a><span class="co">         * p-&gt;real_parent-&gt;pid)</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_struct <span class="op">*</span>real_parent<span class="op">;</span> <span class="co">/* real parent process */</span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_struct <span class="op">*</span>parent<span class="op">;</span>      <span class="co">/* recipient of SIGCHLD, wait4() reports */</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a><span class="co">         * children/sibling forms the list of my natural children</span></span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head    children<span class="op">;</span>     <span class="co">/* list of my children */</span></span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head    sibling<span class="op">;</span>      <span class="co">/* linkage in my parent&#39;s children list */</span></span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_struct <span class="op">*</span>group_leader<span class="op">;</span> <span class="co">/* threadgroup leader */</span></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a><span class="co">         * ptraced is the list of tasks this task is using ptrace on.</span></span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a><span class="co">         * This includes both natural children and PTRACE_ATTACH targets.</span></span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a><span class="co">         * p-&gt;ptrace_entry is p&#39;s link on the p-&gt;parent-&gt;ptraced list.</span></span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head ptraced<span class="op">;</span></span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head ptrace_entry<span class="op">;</span></span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* PID/PID hash table linkage. */</span></span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> pid_link  pids<span class="op">[</span>PIDTYPE_MAX<span class="op">];</span></span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head thread_group<span class="op">;</span></span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> completion <span class="op">*</span>vfork_done<span class="op">;</span> <span class="co">/* for vfork() */</span></span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> __user <span class="op">*</span>set_child_tid<span class="op">;</span>     <span class="co">/* CLONE_CHILD_SETTID */</span></span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> __user <span class="op">*</span>clear_child_tid<span class="op">;</span>   <span class="co">/* CLONE_CHILD_CLEARTID */</span></span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>        cputime_t utime<span class="op">,</span> stime<span class="op">,</span> utimescaled<span class="op">,</span> stimescaled<span class="op">;</span></span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>        cputime_t gtime<span class="op">;</span></span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span></span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a>        cputime_t prev_utime<span class="op">,</span> prev_stime<span class="op">;</span></span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span>   nvcsw<span class="op">,</span> nivcsw<span class="op">;</span>   <span class="co">/* context switch counts */</span></span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> timespec start_time<span class="op">;</span>      <span class="co">/* monotonic time */</span></span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> timespec real_start_time<span class="op">;</span> <span class="co">/* boot based time */</span></span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* mm fault and swap info: this can arguably be seen as either mm-specific</span></span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a><span class="co">         * or thread-specific */</span></span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> min_flt<span class="op">,</span> maj_flt<span class="op">;</span></span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_cputime cputime_expires<span class="op">;</span></span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head    cpu_timers<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* process credentials */</span></span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>        <span class="dt">const</span> <span class="kw">struct</span> cred __rcu <span class="op">*</span>real_cred<span class="op">;</span> <span class="co">/* objective and real subjective task</span></span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a><span class="co">                                             * credentials (COW) */</span></span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a>        <span class="dt">const</span> <span class="kw">struct</span> cred __rcu <span class="op">*</span>cred<span class="op">;</span> <span class="co">/* effective (overridable) subjective task</span></span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a><span class="co">                                        * credentials (COW) */</span></span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> cred <span class="op">*</span>replacement_session_keyring<span class="op">;</span> <span class="co">/* for KEYCTL_SESSION_TO_PARENT */</span></span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> comm<span class="op">[</span>TASK_COMM_LEN<span class="op">];</span> <span class="co">/* executable name excluding path</span></span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a><span class="co">                                     - access with [gs]et_task_comm (which lock</span></span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a><span class="co">                                     it with task_lock())</span></span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a><span class="co">                                     - initialized normally by setup_new_exec */</span></span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* file system info */</span></span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> link_count<span class="op">,</span> total_link_count<span class="op">;</span></span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_SYSVIPC</span></span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* ipc stuff */</span></span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sysv_sem sysvsem<span class="op">;</span></span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-160"><a href="#cb2-160" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_DETECT_HUNG_TASK</span></span>
<span id="cb2-161"><a href="#cb2-161" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* hung task detection */</span></span>
<span id="cb2-162"><a href="#cb2-162" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> last_switch_count<span class="op">;</span></span>
<span id="cb2-163"><a href="#cb2-163" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-164"><a href="#cb2-164" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* CPU-specific state of this task */</span></span>
<span id="cb2-165"><a href="#cb2-165" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> thread_struct thread<span class="op">;</span></span>
<span id="cb2-166"><a href="#cb2-166" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* filesystem information */</span></span>
<span id="cb2-167"><a href="#cb2-167" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> fs_struct <span class="op">*</span>fs<span class="op">;</span></span>
<span id="cb2-168"><a href="#cb2-168" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* open file information */</span></span>
<span id="cb2-169"><a href="#cb2-169" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> files_struct <span class="op">*</span>files<span class="op">;</span></span>
<span id="cb2-170"><a href="#cb2-170" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* namespaces */</span></span>
<span id="cb2-171"><a href="#cb2-171" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> nsproxy <span class="op">*</span>nsproxy<span class="op">;</span></span>
<span id="cb2-172"><a href="#cb2-172" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* signal handlers */</span></span>
<span id="cb2-173"><a href="#cb2-173" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> signal_struct <span class="op">*</span> signal<span class="op">;</span></span>
<span id="cb2-174"><a href="#cb2-174" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sighand_struct <span class="op">*</span>sighand<span class="op">;</span></span>
<span id="cb2-175"><a href="#cb2-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-176"><a href="#cb2-176" aria-hidden="true" tabindex="-1"></a>        sigset_t blocked<span class="op">,</span> real_blocked<span class="op">;</span></span>
<span id="cb2-177"><a href="#cb2-177" aria-hidden="true" tabindex="-1"></a>        sigset_t saved_sigmask<span class="op">;</span> <span class="co">/* restored if set_restore_sigmask() was used */</span></span>
<span id="cb2-178"><a href="#cb2-178" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sigpending pending<span class="op">;</span></span>
<span id="cb2-179"><a href="#cb2-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-180"><a href="#cb2-180" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> sas_ss_sp<span class="op">;</span></span>
<span id="cb2-181"><a href="#cb2-181" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>        sas_ss_size<span class="op">;</span></span>
<span id="cb2-182"><a href="#cb2-182" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">(*</span>notifier<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>priv<span class="op">);</span></span>
<span id="cb2-183"><a href="#cb2-183" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="op">*</span>                notifier_data<span class="op">;</span></span>
<span id="cb2-184"><a href="#cb2-184" aria-hidden="true" tabindex="-1"></a>        sigset_t <span class="op">*</span>            notifier_mask<span class="op">;</span></span>
<span id="cb2-185"><a href="#cb2-185" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> audit_context <span class="op">*</span>audit_context<span class="op">;</span></span>
<span id="cb2-186"><a href="#cb2-186" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_AUDITSYSCALL</span></span>
<span id="cb2-187"><a href="#cb2-187" aria-hidden="true" tabindex="-1"></a>        uid_t        loginuid<span class="op">;</span></span>
<span id="cb2-188"><a href="#cb2-188" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> sessionid<span class="op">;</span></span>
<span id="cb2-189"><a href="#cb2-189" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-190"><a href="#cb2-190" aria-hidden="true" tabindex="-1"></a>        seccomp_t seccomp<span class="op">;</span></span>
<span id="cb2-191"><a href="#cb2-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-192"><a href="#cb2-192" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Thread group tracking */</span></span>
<span id="cb2-193"><a href="#cb2-193" aria-hidden="true" tabindex="-1"></a>        u32 parent_exec_id<span class="op">;</span></span>
<span id="cb2-194"><a href="#cb2-194" aria-hidden="true" tabindex="-1"></a>        u32 self_exec_id<span class="op">;</span></span>
<span id="cb2-195"><a href="#cb2-195" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings,</span></span>
<span id="cb2-196"><a href="#cb2-196" aria-hidden="true" tabindex="-1"></a><span class="co">         * mems_allowed, mempolicy */</span></span>
<span id="cb2-197"><a href="#cb2-197" aria-hidden="true" tabindex="-1"></a>        spinlock_t alloc_lock<span class="op">;</span></span>
<span id="cb2-198"><a href="#cb2-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-199"><a href="#cb2-199" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_GENERIC_HARDIRQS</span></span>
<span id="cb2-200"><a href="#cb2-200" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* IRQ handler threads */</span></span>
<span id="cb2-201"><a href="#cb2-201" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> irqaction <span class="op">*</span>irqaction<span class="op">;</span></span>
<span id="cb2-202"><a href="#cb2-202" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-203"><a href="#cb2-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-204"><a href="#cb2-204" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Protection of the PI data structures: */</span></span>
<span id="cb2-205"><a href="#cb2-205" aria-hidden="true" tabindex="-1"></a>        raw_spinlock_t pi_lock<span class="op">;</span></span>
<span id="cb2-206"><a href="#cb2-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-207"><a href="#cb2-207" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_RT_MUTEXES</span></span>
<span id="cb2-208"><a href="#cb2-208" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* PI waiters blocked on a rt_mutex held by this task */</span></span>
<span id="cb2-209"><a href="#cb2-209" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> plist_head pi_waiters<span class="op">;</span></span>
<span id="cb2-210"><a href="#cb2-210" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Deadlock detection and priority inheritance handling */</span></span>
<span id="cb2-211"><a href="#cb2-211" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> rt_mutex_waiter <span class="op">*</span>pi_blocked_on<span class="op">;</span></span>
<span id="cb2-212"><a href="#cb2-212" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-213"><a href="#cb2-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-214"><a href="#cb2-214" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_DEBUG_MUTEXES</span></span>
<span id="cb2-215"><a href="#cb2-215" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* mutex deadlock detection */</span></span>
<span id="cb2-216"><a href="#cb2-216" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> mutex_waiter <span class="op">*</span>blocked_on<span class="op">;</span></span>
<span id="cb2-217"><a href="#cb2-217" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-218"><a href="#cb2-218" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_TRACE_IRQFLAGS</span></span>
<span id="cb2-219"><a href="#cb2-219" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  irq_events<span class="op">;</span></span>
<span id="cb2-220"><a href="#cb2-220" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> hardirq_enable_ip<span class="op">;</span></span>
<span id="cb2-221"><a href="#cb2-221" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> hardirq_disable_ip<span class="op">;</span></span>
<span id="cb2-222"><a href="#cb2-222" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  hardirq_enable_event<span class="op">;</span></span>
<span id="cb2-223"><a href="#cb2-223" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  hardirq_disable_event<span class="op">;</span></span>
<span id="cb2-224"><a href="#cb2-224" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>           hardirqs_enabled<span class="op">;</span></span>
<span id="cb2-225"><a href="#cb2-225" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>           hardirq_context<span class="op">;</span></span>
<span id="cb2-226"><a href="#cb2-226" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> softirq_disable_ip<span class="op">;</span></span>
<span id="cb2-227"><a href="#cb2-227" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> softirq_enable_ip<span class="op">;</span></span>
<span id="cb2-228"><a href="#cb2-228" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  softirq_disable_event<span class="op">;</span></span>
<span id="cb2-229"><a href="#cb2-229" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>  softirq_enable_event<span class="op">;</span></span>
<span id="cb2-230"><a href="#cb2-230" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>           softirqs_enabled<span class="op">;</span></span>
<span id="cb2-231"><a href="#cb2-231" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>           softirq_context<span class="op">;</span></span>
<span id="cb2-232"><a href="#cb2-232" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-233"><a href="#cb2-233" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_LOCKDEP</span></span>
<span id="cb2-234"><a href="#cb2-234" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX_LOCK_DEPTH 48UL</span></span>
<span id="cb2-235"><a href="#cb2-235" aria-hidden="true" tabindex="-1"></a>        u64              curr_chain_key<span class="op">;</span></span>
<span id="cb2-236"><a href="#cb2-236" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              lockdep_depth<span class="op">;</span></span>
<span id="cb2-237"><a href="#cb2-237" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>     lockdep_recursion<span class="op">;</span></span>
<span id="cb2-238"><a href="#cb2-238" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> held_lock held_locks<span class="op">[</span>MAX_LOCK_DEPTH<span class="op">];</span></span>
<span id="cb2-239"><a href="#cb2-239" aria-hidden="true" tabindex="-1"></a>        gfp_t            lockdep_reclaim_gfp<span class="op">;</span></span>
<span id="cb2-240"><a href="#cb2-240" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-241"><a href="#cb2-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-242"><a href="#cb2-242" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* journalling filesystem info */</span></span>
<span id="cb2-243"><a href="#cb2-243" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="op">*</span>journal_info<span class="op">;</span></span>
<span id="cb2-244"><a href="#cb2-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-245"><a href="#cb2-245" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* stacked block device info */</span></span>
<span id="cb2-246"><a href="#cb2-246" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> bio_list <span class="op">*</span>bio_list<span class="op">;</span></span>
<span id="cb2-247"><a href="#cb2-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-248"><a href="#cb2-248" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_BLOCK</span></span>
<span id="cb2-249"><a href="#cb2-249" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* stack plugging */</span></span>
<span id="cb2-250"><a href="#cb2-250" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> blk_plug <span class="op">*</span>plug<span class="op">;</span></span>
<span id="cb2-251"><a href="#cb2-251" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-252"><a href="#cb2-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-253"><a href="#cb2-253" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* VM state */</span></span>
<span id="cb2-254"><a href="#cb2-254" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> reclaim_state <span class="op">*</span>reclaim_state<span class="op">;</span></span>
<span id="cb2-255"><a href="#cb2-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-256"><a href="#cb2-256" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> backing_dev_info <span class="op">*</span>backing_dev_info<span class="op">;</span></span>
<span id="cb2-257"><a href="#cb2-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-258"><a href="#cb2-258" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> io_context <span class="op">*</span>io_context<span class="op">;</span></span>
<span id="cb2-259"><a href="#cb2-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-260"><a href="#cb2-260" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span>             ptrace_message<span class="op">;</span></span>
<span id="cb2-261"><a href="#cb2-261" aria-hidden="true" tabindex="-1"></a>        siginfo_t <span class="op">*</span>               last_siginfo<span class="op">;</span> <span class="co">/* For ptrace use.  */</span></span>
<span id="cb2-262"><a href="#cb2-262" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_io_accounting ioac<span class="op">;</span></span>
<span id="cb2-263"><a href="#cb2-263" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined(CONFIG_TASK_XACCT)</span></span>
<span id="cb2-264"><a href="#cb2-264" aria-hidden="true" tabindex="-1"></a>        u64       acct_rss_mem1<span class="op">;</span> <span class="co">/* accumulated rss usage */</span></span>
<span id="cb2-265"><a href="#cb2-265" aria-hidden="true" tabindex="-1"></a>        u64       acct_vm_mem1<span class="op">;</span>  <span class="co">/* accumulated virtual memory usage */</span></span>
<span id="cb2-266"><a href="#cb2-266" aria-hidden="true" tabindex="-1"></a>        cputime_t acct_timexpd<span class="op">;</span>  <span class="co">/* stime + utime since last update */</span></span>
<span id="cb2-267"><a href="#cb2-267" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-268"><a href="#cb2-268" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_CPUSETS</span></span>
<span id="cb2-269"><a href="#cb2-269" aria-hidden="true" tabindex="-1"></a>        nodemask_t mems_allowed<span class="op">;</span> <span class="co">/* Protected by alloc_lock */</span></span>
<span id="cb2-270"><a href="#cb2-270" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>        mems_allowed_change_disable<span class="op">;</span></span>
<span id="cb2-271"><a href="#cb2-271" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>        cpuset_mem_spread_rotor<span class="op">;</span></span>
<span id="cb2-272"><a href="#cb2-272" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>        cpuset_slab_spread_rotor<span class="op">;</span></span>
<span id="cb2-273"><a href="#cb2-273" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-274"><a href="#cb2-274" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_CGROUPS</span></span>
<span id="cb2-275"><a href="#cb2-275" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Control Group info protected by css_set_lock */</span></span>
<span id="cb2-276"><a href="#cb2-276" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> css_set __rcu <span class="op">*</span>cgroups<span class="op">;</span></span>
<span id="cb2-277"><a href="#cb2-277" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span>
<span id="cb2-278"><a href="#cb2-278" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head cg_list<span class="op">;</span></span>
<span id="cb2-279"><a href="#cb2-279" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-280"><a href="#cb2-280" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_FUTEX</span></span>
<span id="cb2-281"><a href="#cb2-281" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> robust_list_head __user <span class="op">*</span>robust_list<span class="op">;</span></span>
<span id="cb2-282"><a href="#cb2-282" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_COMPAT</span></span>
<span id="cb2-283"><a href="#cb2-283" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> compat_robust_list_head __user <span class="op">*</span>compat_robust_list<span class="op">;</span></span>
<span id="cb2-284"><a href="#cb2-284" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-285"><a href="#cb2-285" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head       pi_state_list<span class="op">;</span></span>
<span id="cb2-286"><a href="#cb2-286" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> futex_pi_state <span class="op">*</span>pi_state_cache<span class="op">;</span></span>
<span id="cb2-287"><a href="#cb2-287" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-288"><a href="#cb2-288" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_PERF_EVENTS</span></span>
<span id="cb2-289"><a href="#cb2-289" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> perf_event_context <span class="op">*</span>perf_event_ctxp<span class="op">[</span>perf_nr_task_contexts<span class="op">];</span></span>
<span id="cb2-290"><a href="#cb2-290" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> mutex               perf_event_mutex<span class="op">;</span></span>
<span id="cb2-291"><a href="#cb2-291" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head           perf_event_list<span class="op">;</span></span>
<span id="cb2-292"><a href="#cb2-292" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-293"><a href="#cb2-293" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_NUMA</span></span>
<span id="cb2-294"><a href="#cb2-294" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> mempolicy <span class="op">*</span>mempolicy<span class="op">;</span> <span class="co">/* Protected by alloc_lock */</span></span>
<span id="cb2-295"><a href="#cb2-295" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span>             il_next<span class="op">;</span></span>
<span id="cb2-296"><a href="#cb2-296" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span>             pref_node_fork<span class="op">;</span></span>
<span id="cb2-297"><a href="#cb2-297" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-298"><a href="#cb2-298" aria-hidden="true" tabindex="-1"></a>        atomic_t        fs_excl<span class="op">;</span> <span class="co">/* holding fs exclusive resources */</span></span>
<span id="cb2-299"><a href="#cb2-299" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> rcu_head rcu<span class="op">;</span></span>
<span id="cb2-300"><a href="#cb2-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-301"><a href="#cb2-301" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-302"><a href="#cb2-302" aria-hidden="true" tabindex="-1"></a><span class="co">         * cache last used pipe for splice</span></span>
<span id="cb2-303"><a href="#cb2-303" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-304"><a href="#cb2-304" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> pipe_inode_info <span class="op">*</span>splice_pipe<span class="op">;</span></span>
<span id="cb2-305"><a href="#cb2-305" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_TASK_DELAY_ACCT</span></span>
<span id="cb2-306"><a href="#cb2-306" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_delay_info <span class="op">*</span>delays<span class="op">;</span></span>
<span id="cb2-307"><a href="#cb2-307" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-308"><a href="#cb2-308" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_FAULT_INJECTION</span></span>
<span id="cb2-309"><a href="#cb2-309" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> make_it_fail<span class="op">;</span></span>
<span id="cb2-310"><a href="#cb2-310" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-311"><a href="#cb2-311" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> prop_local_single dirties<span class="op">;</span></span>
<span id="cb2-312"><a href="#cb2-312" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_LATENCYTOP</span></span>
<span id="cb2-313"><a href="#cb2-313" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>                   latency_record_count<span class="op">;</span></span>
<span id="cb2-314"><a href="#cb2-314" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> latency_record latency_record<span class="op">[</span>LT_SAVECOUNT<span class="op">];</span></span>
<span id="cb2-315"><a href="#cb2-315" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-316"><a href="#cb2-316" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-317"><a href="#cb2-317" aria-hidden="true" tabindex="-1"></a><span class="co">         * time slack values; these are used to round up poll() and</span></span>
<span id="cb2-318"><a href="#cb2-318" aria-hidden="true" tabindex="-1"></a><span class="co">         * select() etc timeout values. These are in nanoseconds.</span></span>
<span id="cb2-319"><a href="#cb2-319" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-320"><a href="#cb2-320" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> timer_slack_ns<span class="op">;</span></span>
<span id="cb2-321"><a href="#cb2-321" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> default_timer_slack_ns<span class="op">;</span></span>
<span id="cb2-322"><a href="#cb2-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-323"><a href="#cb2-323" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head <span class="op">*</span>scm_work_list<span class="op">;</span></span>
<span id="cb2-324"><a href="#cb2-324" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span></span>
<span id="cb2-325"><a href="#cb2-325" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Index of current stored address in ret_stack */</span></span>
<span id="cb2-326"><a href="#cb2-326" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> curr_ret_stack<span class="op">;</span></span>
<span id="cb2-327"><a href="#cb2-327" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Stack of return addresses for return function tracing */</span></span>
<span id="cb2-328"><a href="#cb2-328" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> ftrace_ret_stack <span class="op">*</span>ret_stack<span class="op">;</span></span>
<span id="cb2-329"><a href="#cb2-329" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* time stamp for last schedule */</span></span>
<span id="cb2-330"><a href="#cb2-330" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ftrace_timestamp<span class="op">;</span></span>
<span id="cb2-331"><a href="#cb2-331" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb2-332"><a href="#cb2-332" aria-hidden="true" tabindex="-1"></a><span class="co">         * Number of functions that haven&#39;t been traced</span></span>
<span id="cb2-333"><a href="#cb2-333" aria-hidden="true" tabindex="-1"></a><span class="co">         * because of depth overrun.</span></span>
<span id="cb2-334"><a href="#cb2-334" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb2-335"><a href="#cb2-335" aria-hidden="true" tabindex="-1"></a>        atomic_t trace_overrun<span class="op">;</span></span>
<span id="cb2-336"><a href="#cb2-336" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Pause for the tracing */</span></span>
<span id="cb2-337"><a href="#cb2-337" aria-hidden="true" tabindex="-1"></a>        atomic_t tracing_graph_pause<span class="op">;</span></span>
<span id="cb2-338"><a href="#cb2-338" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-339"><a href="#cb2-339" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_TRACING</span></span>
<span id="cb2-340"><a href="#cb2-340" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* state flags for use by tracers */</span></span>
<span id="cb2-341"><a href="#cb2-341" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> trace<span class="op">;</span></span>
<span id="cb2-342"><a href="#cb2-342" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* bitmask of trace recursion */</span></span>
<span id="cb2-343"><a href="#cb2-343" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> trace_recursion<span class="op">;</span></span>
<span id="cb2-344"><a href="#cb2-344" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif                            </span><span class="co">/* CONFIG_TRACING */</span></span>
<span id="cb2-345"><a href="#cb2-345" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR </span><span class="co">/* memcg uses this to do batch job */</span></span>
<span id="cb2-346"><a href="#cb2-346" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> memcg_batch_info <span class="op">{</span></span>
<span id="cb2-347"><a href="#cb2-347" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> do_batch<span class="op">;</span>             <span class="co">/* incremented when batch uncharge started */</span></span>
<span id="cb2-348"><a href="#cb2-348" aria-hidden="true" tabindex="-1"></a>                <span class="kw">struct</span> mem_cgroup <span class="op">*</span>memcg<span class="op">;</span> <span class="co">/* target memcg of uncharge */</span></span>
<span id="cb2-349"><a href="#cb2-349" aria-hidden="true" tabindex="-1"></a>                <span class="dt">unsigned</span> <span class="dt">long</span>      nr_pages<span class="op">;</span>       <span class="co">/* uncharged usage */</span></span>
<span id="cb2-350"><a href="#cb2-350" aria-hidden="true" tabindex="-1"></a>                <span class="dt">unsigned</span> <span class="dt">long</span>      memsw_nr_pages<span class="op">;</span> <span class="co">/* uncharged mem+swap usage */</span></span>
<span id="cb2-351"><a href="#cb2-351" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> memcg_batch<span class="op">;</span></span>
<span id="cb2-352"><a href="#cb2-352" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-353"><a href="#cb2-353" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span></span>
<span id="cb2-354"><a href="#cb2-354" aria-hidden="true" tabindex="-1"></a>        atomic_t ptrace_bp_refcnt<span class="op">;</span></span>
<span id="cb2-355"><a href="#cb2-355" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb2-356"><a href="#cb2-356" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><a href="ch3/fig-3-1.jpg">Figure 3.1</a></p>
<ol>
<li><p>Allocating the Process Descriptor</p>
<p><code>task_struct</code> is allocated via <em>slab allocator</em>. Prior to the 2.6 kernel series, was stored at the end of the kernel stack of each process.</p>
<p><code>struct task_struct</code> was stored at the end of the kernel stack of each process.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> thread_info <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> task_struct   <span class="op">*</span>task<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> exec_domain   <span class="op">*</span>exec_domain<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        __u32                 flags<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        __u32                 status<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        __u32                 cpu<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>                   preept_count<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        mm_segment_t          addr_limit<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> restart_block  restart_block<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>                 <span class="op">*</span>sysenter_return<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>                   uaccess_err<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>Storing the Process Descriptor</p>
<p>maximum value of <em>PID</em>: <code>/proc/sys/kernel/pid_max/</code></p>
<p>most kernel code deals with processes works directly with <code>strcut task_struct</code></p>
<p>some architectures save a pointer to the <code>task_struct</code> of the currently running process in a register, others use <code>struct thread_info</code> to calculate the location of <code>thread_info</code> and <code>task_struct</code>.</p></li>
<li><p>Process State</p>
<blockquote>
<ul>
<li>TASK<sub>RUNNING</sub> - runnable, either running or on a runqueue waiting to run</li>
<li>TASK<sub>INTERRUPTIBLE</sub> - sleeping,</li>
<li>TASK<sub>UNINTERRUPTIBLE</sub> - <strong>DOES NOT</strong> wake up and become runnable if it receives a signal. used when the process must wait without interruption or when the event is excepted to occur quite quickly.</li>
<li>_<sub>TASKTRACED</sub> - being traced by another process, such as a debugger, via <em>ptrace</em></li>
<li>_<sub>TASKSTOPED</sub> - is not running nor eligible to run. <code>SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU</code> or <em>any</em> signal while it is being debugged.</li>
</ul>
</blockquote></li>
<li><p>Manipulating the Current Process State</p>
<p><code>set_task_state(task, state)</code> to change process's state. is equivalent to <code>task-&gt;state = state;</code></p></li>
<li><p>Process Context</p>
<p>normal in <em>user-space</em>. enters <em>kernel-space</em> when executes a system call or triggers an exception.</p></li>
<li><p>The Process Family Tree</p>
<p>ALl processes are descendants of <code>init</code> process, PID=1.</p>
<p>The <code>init</code> process reads the system <em>initscripts</em> and executes more programs, eventually completing the boot process.</p>
<p>obtain process descriptor of current process's parent:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">*</span>my_parent <span class="op">=</span> current<span class="op">-&gt;</span>parent<span class="op">;</span></span></code></pre></div>
<p>iterate over a process's children:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> list_head <span class="op">*</span>list<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>list_for_each<span class="op">(</span>list<span class="op">,</span> <span class="op">&amp;</span>current<span class="op">-&gt;</span>children<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        task <span class="op">=</span> list_entry<span class="op">(</span>list<span class="op">,</span> <span class="kw">struct</span> task_struct<span class="op">,</span> sibling<span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span class="title-ref">iterator for init process &lt;ch3/iterator/it.c::include &lt;linux/init.h&gt;&gt;</span>__</p>
<p>a good example of the relationship between all processes :</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>task <span class="op">=</span> current<span class="op">;</span> task <span class="op">!=</span> <span class="op">&amp;</span>init_task<span class="op">;</span> task <span class="op">=</span> task<span class="op">-&gt;</span>parent<span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">/* task now points to init */</span></span></code></pre></div>
<p>obtain the next task in the list:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>list_entry<span class="op">(</span>task<span class="op">-&gt;</span>tasks<span class="op">.</span>next<span class="op">,</span> <span class="kw">struct</span> task_struct<span class="op">,</span> tasks<span class="op">)</span></span></code></pre></div>
<p>obtain the previous task in the list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>list_entry<span class="op">(</span>tasks<span class="op">.</span>prev<span class="op">,</span> <span class="kw">struct</span> task_struct<span class="op">,</span> tasks<span class="op">)</span></span></code></pre></div>
<p>macro for iterating entire task list:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>for_each_process<span class="op">(</span>task<span class="op">)</span> <span class="op">{</span> printk<span class="op">(</span><span class="st">&quot;%s[%d]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> task<span class="op">-&gt;</span>comm<span class="op">,</span> task<span class="op">-&gt;</span>pid<span class="op">);</span> <span class="op">}</span></span></code></pre></div></li>
</ol>
<h4 id="process-creation">Process Creation</h4>
<p><code>fork()</code>, differs from the parent only in its PID, its PPID and certain resources and statistics, which are no inherited.</p>
<p><code>exec()</code>, loads a new executable into the addres space and begins executing it.</p>
<ol>
<li><p>Copy-on-Write</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Copy-on-write">Copy-on-write -Wikipedia</a></li>
</ul>
<p>Copy only when modified, share the same one if readonly. A resource is duplicated but not modified, it is not necessary to create a new resource.</p></li>
<li><p>Forking</p>
<p><code>clone</code> calls with requisite flags, calls <code>do_fork()</code></p></li>
<li><p><code>vfork</code></p>
<p>the page table entries of the parent process are not copied.</p>
<p>implemented via a special flag to <code>clone()</code> system call:</p>
<blockquote>
<ol>
<li>In <code>copy_process()</code>, the task<sub>struct</sub> member <code>vfork_done()</code> is set to NULL</li>
<li>In <code>do_fork()</code>, if the special flag was given, <code>vfork_done()</code> is pointed to a specific address</li>
<li>After the child is first run, the parent waits for the child to signal it through the <code>vfork_done()</code> pointer.</li>
<li>In the <code>mm_release()</code> function, <code>vfork_done()</code> is checked to see if it is NULL, then the parent is signaled.</li>
<li>Back in <code>do_fork()</code>, the parents wakes up and returns.</li>
</ol>
</blockquote></li>
</ol>
<h4 id="the-linux-implementation-of-threads">The Linux Implementation of Threads</h4>
<p>Threads share open files and other resources. Threads enable <em>concurrent programming</em> and, on multiple processor systems, true <em>parallelism</em>.</p>
<p><strong>A thread is merely a process that shares certain resources with other processes.</strong></p>
<p><strong>Each thread has a unique ``task_struct`` and appears to the kernel as a normal process - threads just happen to share resources.</strong></p>
<ol>
<li><p>Creating Threads</p>
<p>the same as normal tasks, but passed flags corresponding to the specific resources to be shared</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>clone <span class="op">(</span>CLONE_VM <span class="op">|</span> CLONE_FS <span class="op">|</span> CLONE_FILES <span class="op">|</span> CLONE_SIGHAND<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<ul>
<li><p><code>fork()</code></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>clone<span class="op">(</span>SIGCHLD<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div></li>
<li><p><code>vfork()</code></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>clone<span class="op">(</span>CLONE_VFORK <span class="op">|</span> CLONE_VM <span class="op">|</span> SIGCHLD<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div></li>
</ul>
<table style="width:97%;">
<caption>Table 1: Table 3.1. <code>clone()</code> Flags</caption>
<colgroup>
<col style="width: 41%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CLONE<sub>FILES</sub></td>
<td>Parent and child share open files</td>
</tr>
<tr class="even">
<td>CLONE<sub>FS</sub></td>
<td>Parent and child share filesystem information</td>
</tr>
<tr class="odd">
<td>CLONE<sub>IDLETASK</sub></td>
<td>Set PID to zero (used only by the idle tasks)</td>
</tr>
<tr class="even">
<td>CLONE<sub>NEWS</sub></td>
<td>Create a new namespace for the child</td>
</tr>
<tr class="odd">
<td>CLONE<sub>PARENT</sub></td>
<td>Child is to have some parent as its parent</td>
</tr>
<tr class="even">
<td>CLONE<sub>PTRACE</sub></td>
<td>Continuing tracing child</td>
</tr>
<tr class="odd">
<td>CLONE<sub>SETTID</sub></td>
<td>Write the TID back to user-space</td>
</tr>
<tr class="even">
<td>CLONE<sub>SETTLS</sub></td>
<td>Create a new TLS for the child</td>
</tr>
<tr class="odd">
<td>CLONE<sub>SIGHAND</sub></td>
<td>Parent and child share signal handler and blocked signals</td>
</tr>
<tr class="even">
<td>CLONE<sub>SYSVSEM</sub></td>
<td>Parent and child share System V <code>SEM_UNDO</code> semantics</td>
</tr>
<tr class="odd">
<td>CLONE<sub>THREAD</sub></td>
<td>Parent and child are in the same thread group</td>
</tr>
<tr class="even">
<td>CLONE<sub>VFORK</sub></td>
<td><code>vfork()</code> was used and the parent will sleep until the child wakes it</td>
</tr>
<tr class="odd">
<td>CLONE<sub>UNTRACED</sub></td>
<td>Do not let the tracing process force CLONE<sub>PTRACE</sub> on the child</td>
</tr>
<tr class="even">
<td>CLONE<sub>STOP</sub></td>
<td>Start process in the <code>TASK_STOPPED</code> state.</td>
</tr>
<tr class="odd">
<td>CLONE<sub>SETTLS</sub></td>
<td>Create a new TLS (thread-local storage) for the child</td>
</tr>
<tr class="even">
<td>CLONE<sub>CHILDCLEARTID</sub></td>
<td>Clear the TID int he child</td>
</tr>
<tr class="odd">
<td>CLONE<sub>CHILDSETTID</sub></td>
<td>Set the TID in the child.</td>
</tr>
<tr class="even">
<td>CLONE<sub>PARENTSETTID</sub></td>
<td>Set the TID in the parent.</td>
</tr>
<tr class="odd">
<td>CLONE<sub>VM</sub></td>
<td>Parent and child share address space.</td>
</tr>
</tbody>
</table></li>
<li><p>Kernel Threads</p>
<blockquote>
<p>The significant difference between kernel threads and normal processes is that kernel threads do not have an address space. (Their <code>mm</code> pointer, which points at their address space, is <code>NULL</code>).</p>
</blockquote>
<p>interface declared in <code>&lt;linux/kthread.h&gt;</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">*</span>kthread_create<span class="op">(</span><span class="dt">int</span> <span class="op">(*</span>threadfn<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>data<span class="op">),</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">,</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">const</span> <span class="dt">char</span> namefmt<span class="op">[],</span> <span class="op">...);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * kthread_create - create a kthread on the current node</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@threadfn:</span><span class="co"> the function to run in the thread</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@data:</span><span class="co"> data pointer for </span><span class="an">@threadfn()</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@namefmt:</span><span class="co"> printf-style format string for the thread name</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@arg</span><span class="co">...: arguments for </span><span class="an">@namefmt.</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * This macro will create a kthread on the current node, leaving it in</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * the stopped state.  This is just a helper for kthread_create_on_node();</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * see the documentation there for more details.</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define kthread_create(threadfn, data, namefmt, arg...)                 \</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="pp">        kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task_struct <span class="op">*</span>kthread_run<span class="op">(</span><span class="dt">int</span> <span class="op">(*</span>threadfn<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>data<span class="op">),</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">,</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>                                <span class="dt">const</span> <span class="dt">char</span> namefmt<span class="op">[],</span> <span class="op">...);</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * kthread_run - create and wake a thread.</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@threadfn:</span><span class="co"> the function to run until signal_pending(current).</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@data:</span><span class="co"> data ptr for </span><span class="an">@threadfn.</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@namefmt:</span><span class="co"> printf-style name for the thread.</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * Description: Convenient wrapper for kthread_create() followed by</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="pp">#define kthread_run(threadfn, data, namefmt, ...)                       \</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="pp">        ({                                                              \</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a><span class="pp">                struct task_struct *__k =                               \</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="pp">                        kthread_create(threadfn, data, namefmt, ##__VA_ARGS__); \</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a><span class="pp">                if (!IS_ERR(__k)) wake_up_process(__k);                 \</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="pp">                __k;                                                    \</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span class="pp">        })</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> kthread_stop<span class="op">(</span><span class="kw">struct</span> task_struct <span class="op">*</span>k<span class="op">);</span></span></code></pre></div></li>
</ol>
<h4 id="process-termination">Process Termination</h4>
<p><code>do_exit()</code></p>
<ol>
<li><p><code>PF_EXITING</code> for <code>flags</code> of the <code>struct task_struct</code></p></li>
<li><p>calls <code>del_timer_sync()</code></p></li>
<li><p><code>if (BSD process accounting) { acct_update_integrals(); }</code></p></li>
<li><p>calls <code>exit_mm()</code> to release the <code>mm_struct</code></p></li>
<li><p>calls <code>exit_sem()</code> to dequeue IPC semaphore.</p></li>
<li><p>calls <code>exit_files()</code> and <code>exit_fs()</code> to decrement the usage count of file descriptors and filesystem data.</p></li>
<li><p>set exit code stored <code>exit_code</code> in the <code>task_struct</code></p></li>
<li><p>calls <code>exit_notify()</code> to send signals to the task's parent, reparents any of the task's chidren to another thread in their thread group or the init process, and sets <code>exit_state=EXIT_ZOMBIE</code></p></li>
<li><p>calls <code>schedule()</code> to switch to a new process. <code>do_exit()</code> never returns.</p></li>
<li><p>Removing the Process Descriptor</p>
<p><code>release_task()</code></p>
<ol>
<li>calls <code>__exit_signal()</code>, which calls <code>__unhash_process()</code>, which in turns calls <code>detach_pid()</code> to remove the process from the pidhash and task<sub>list</sub>.</li>
<li><code>__eixt_signal()</code> releases any remaining resources used by</li>
<li><code>if (last member &amp;&amp; leader == zombie) { release_task(); }</code></li>
<li><code>release_task()</code> calls <code>put_task_struct()</code> to free the pages for <code>thread_info</code> and deallocate the slab cache for <code>task_struct</code></li>
</ol></li>
<li><p>The Dilemma of the Parentless Task</p>
<p><code>exit_notify()</code> -&gt; <code>forget_original_parent()</code> -&gt; <code>find_new_reaper()</code> to perform the reparenting.</p></li>
</ol>
<h3 id="process-scheduling">4 Process Scheduling</h3>
<p>The process scheduler decides which process runs, when, and for how long.</p>
<h4 id="multitaksing">Multitaksing</h4>
<p>A <em>multitasking</em> operating system is one that can simultaneously interleave execution of more than one process.</p>
<p>two flavors: <em>coorperative multitasking</em> and <em>preemptive multitasking</em>.</p>
<ul>
<li><em>preemptive multitasking</em>, the scheduler decides when a process is to cease running and a new process is to begin running.</li>
<li><em>coorperative multitasking</em>, a process does not stop running until it voluntary decides to do so.</li>
</ul>
<p>Timeslice: gives each runnable process a <em>slice</em> of the processor's time</p>
<h4 id="linuxs-process-scheduler">Linux's Process Scheduler</h4>
<p>CFS: Completely Fair Scheduler.</p>
<h4 id="policy">Policy</h4>
<ol>
<li><p>I/O-Bound Versus Processor-Bound Processes</p>
<ul>
<li>I/O-bound process, spends much of its time submitting and waiting on I/O requests.</li>
<li>processor-bound process, spends much of their time executing code.</li>
</ul></li>
<li><p>Process Priority</p>
<p>priorty-based scheduling: A common type of scheduling algrithm. The goal is to rank processes based on their worth and need for processor time.</p>
<p>The Linux kernel implements two seperate two priority ranges:</p>
<ul>
<li><p><em>nice</em> value: -20 to +19, with a default of 0.</p></li>
</ul>
<p>#+caption: correspondence between value and priority</p>
<table style="width:51%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 25%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>column</th>
<th>from -&gt; to</th>
<th>hello</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>larger-&gt;smaller</td>
<td></td>
</tr>
<tr class="even">
<td>priority</td>
<td>lower-&gt;higher</td>
<td></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span> <span class="at">-eo</span> state,uid,pid,ppid,rtprio,time,comm</span></code></pre></div>
<ul>
<li><p><em>real-time</em> priority (<em>RTPRIO</em>):</p>
<p>opposite from nice values, higher real-time priority values correspond to a greater priority.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span> <span class="at">-eo</span> state,uid,pid,ppid,rtprio,time,comm</span></code></pre></div></li>
</ul></li>
<li><p>Timeslice</p>
<p>The timesilce is the number value that represents how long a task can run until it is preempted.</p>
<ul>
<li>Too long timeslice causes the system doesn't know if the process executed.</li>
<li>Too short timeslice causes the system wastes too much processor time switching between processes.</li>
<li>I/O-bound processes do not need longer timeslices</li>
<li>processor-bound processes crave long timeslices.</li>
</ul>
<p>In a novel approach, Linux's CFS Scheduler assigns processes a <em>proportion</em> of the processor.</p>
<p>Processes with higher nice values (a lower priority) receive a deflationary weight, yielding them a smaller proportion of the processor; processes with smaller nice values (a higher priority) receive an inflationary weight, netting them a larger proportion of the processor.</p>
<p>The Linux operating system is preemptive.</p></li>
<li><p>The Scheduling Policy in Action</p></li>
</ol>
<h4 id="the-linux-scheduling-algorithm">The Linux Scheduling Algorithm</h4>
<ol>
<li><p>Scheduler Classes</p>
<p>Scheduler classes enable different, pluggable alogirhtms to coexist, scheduling their own types of processes.</p></li>
<li><p>Process Scheduling in Unix Systems</p>
<p>scheduler common concepts: processes priority and timeslice.</p>
<p>pathological problems:</p>
<ul>
<li>mapping nice values onto timeslices requires a decision about what absolute timeslice to allot each nice value.</li>
<li>concers relative nice values and again the nice value to timeslice mapping.</li>
<li>if performing a nice value to timeslice mapping, we need the ability to assign an absolute timeslice.</li>
<li>concerns handling process wake up in a priority based scheduler that wants to optimize for interactive tasks.</li>
</ul></li>
<li><p>Fair Scheduling</p>
<p>CFS uses the nice value to <em>weight</em> the proportion of processor a process is to receive: Higher valued (lower priority) processes receive a fractional weight relative to the default nice value, whereas lower valued (higher priority) processes receive a larger weight.</p></li>
</ol>
<h4 id="the-linux-scheduling-implementation">The Linux Scheduling Implementation</h4>
<ol>
<li><p>Time Accounting</p>
<p>All processes schedulers must account for the time that a process runs.</p>
<ol>
<li><p>The scheduler Entity Structure</p>
<p>CFS does not have the notion of a timeslice, but it must still keep account for the time that each process runs.</p>
<p><strong>It's quite different from the book, that should be the version upgrade changes</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sched_entity <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* For load-balancing: */</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> load_weight              load<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span>                   runnable_weight<span class="op">;</span> <span class="co">/* not in book */</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> rb_node                  run_node<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head                group_node<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span>                    on_rq<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        u64                             exec_start<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        u64                             sum_exec_runtime<span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        u64                             vruntime<span class="op">;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        u64                             prev_sum_exec_runtime<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#if 0</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="co">        u64                             last_wakeup;        /* only in book */</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co">        u64                             avg_overlap;        /* only in book */</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        u64                             nr_migrations<span class="op">;</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#if 0</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="co">        u64                             start_runtime;      /* only in book */</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="co">        u64                             avg_wakeup;         /* only in book */</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_statistics         statistics<span class="op">;</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_FAIR_GROUP_SCHED</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>                             depth<span class="op">;</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_entity             <span class="op">*</span>parent<span class="op">;</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* rq on which this entity is (to be) queued: */</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> cfs_rq                   <span class="op">*</span>cfs_rq<span class="op">;</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* rq &quot;owned&quot; by this entity/group: */</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> cfs_rq                   <span class="op">*</span>my_q<span class="op">;</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CONFIG_SMP</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a><span class="co">         * Per entity load average tracking.</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a><span class="co">         *</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a><span class="co">         * Put into separate cache line so it does not</span></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a><span class="co">         * collide with read-mostly values above.</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_avg                avg<span class="op">;</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>The Virtual Runtime</p>
<p>The <code>vruntime</code> variable stores the <em>virtual runtime</em> of a process, which is the actual runtime normarized by the number of runnable processes.</p>
<p>CFS uses <code>vruntime</code> to account for how long a process has run and thus how much longer it ought to run.</p>
<p>The function <code>update_curr()</code>, manages this accounting (<strong>Also, it changes a lot from the book</strong>):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> update_curr<span class="op">(</span><span class="kw">struct</span> cfs_rq <span class="op">*</span>cfs_rq<span class="op">)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sched_entity <span class="op">*</span>curr <span class="op">=</span> cfs_rq<span class="op">-&gt;</span>curr<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        u64 now <span class="op">=</span> rq_clock_task<span class="op">(</span>rq_of<span class="op">(</span>cfs_rq<span class="op">));</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        u64 delta_exec<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>unlikely<span class="op">(!</span>curr<span class="op">))</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        delta_exec <span class="op">=</span> now <span class="op">-</span> curr<span class="op">-&gt;</span>exec_start<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>unlikely<span class="op">((</span>s64<span class="op">)</span>delta_exec <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">))</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        curr<span class="op">-&gt;</span>exec_start <span class="op">=</span> now<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        schedstat_set<span class="op">(</span>curr<span class="op">-&gt;</span>statistics<span class="op">.</span>exec_max<span class="op">,</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>                      max<span class="op">(</span>delta_exec<span class="op">,</span> curr<span class="op">-&gt;</span>statistics<span class="op">.</span>exec_max<span class="op">));</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        curr<span class="op">-&gt;</span>sum_exec_runtime <span class="op">+=</span> delta_exec<span class="op">;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        schedstat_add<span class="op">(</span>cfs_rq<span class="op">-&gt;</span>exec_clock<span class="op">,</span> delta_exec<span class="op">);</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        curr<span class="op">-&gt;</span>vruntime <span class="op">+=</span> calc_delta_fair<span class="op">(</span>delta_exec<span class="op">,</span> curr<span class="op">);</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        update_min_vruntime<span class="op">(</span>cfs_rq<span class="op">);</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>entity_is_task<span class="op">(</span>curr<span class="op">))</span> <span class="op">{</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>                <span class="kw">struct</span> task_struct <span class="op">*</span>curtask <span class="op">=</span> task_of<span class="op">(</span>curr<span class="op">);</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>                trace_sched_stat_runtime<span class="op">(</span>curtask<span class="op">,</span> delta_exec<span class="op">,</span> curr<span class="op">-&gt;</span>vruntime<span class="op">);</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>                cgroup_account_cputime<span class="op">(</span>curtask<span class="op">,</span> delta_exec<span class="op">);</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>                account_group_exec_runtime<span class="op">(</span>curtask<span class="op">,</span> delta_exec<span class="op">);</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        account_cfs_rq_runtime<span class="op">(</span>cfs_rq<span class="op">,</span> delta_exec<span class="op">);</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol></li>
<li><p>Process Selection</p></li>
<li><p>The Scheduler Entry Point</p></li>
<li><p>Sleeping and Waking up</p></li>
</ol>
<h3 id="kernel-data-structures">6 Kernel Data Structures</h3>
<h4 id="linked-list">Linked List</h4>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> list_head <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> list_head <span class="op">*</span>prev<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<ul>
<li>TEST: <span class="title-ref">containerof &lt;ch6/container_of.c::include &lt;stdio.h&gt;&gt;</span>__</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define container_of(ptr, type, member)                                 \</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">        ({                                                              \</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="pp">                const typeof(((type *)0)-&gt;member) *__mptr = (ptr);      \</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="pp">                (type *)((char *)__mptr - offsetof(type, member));      \</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="pp">        })</span></span></code></pre></div>
<h3 id="memory-management">12 Memory Management</h3>
<h4 id="zones">Zones</h4>
<p>Linux: two shortcomings of hardware with respect to memory addressing:</p>
<ul>
<li>Some hardware devices can perform DMA (direct memory access) to only certain memory addresses.</li>
<li>Some architectures can physically addressing larger amounts of memory than they can virtually address. Consequently, some memory is not permanently mapped into the kernel address space.</li>
</ul>
<p>Linux has four primary memory zones:</p>
<ul>
<li>ZONE<sub>DMA</sub>: This zone contains pages that can undergo DMA</li>
<li>ZONE<sub>DMA32</sub>: unlike ZONE<sub>DMA</sub>, these pages are accessible only by 32-bit devices.</li>
<li>ZONE<sub>NORMAL</sub>: This zone contains normal, regularly mapped, pages.</li>
<li>ZONE<sub>HIGHMEM</sub>: This zone contains "high memory", which are pages not permanently mapped into the kernel's address space.</li>
</ul>
<table>
<caption>Table 2: Table 12.1 Zones on x86-32</caption>
<thead>
<tr class="header">
<th>Zone</th>
<th>Description</th>
<th>Physical Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ZONE<sub>DMA</sub></td>
<td>DMA-able pages</td>
<td>&lt; 16MB</td>
</tr>
<tr class="even">
<td>ZONE<sub>NORMAL</sub></td>
<td>Normally addressable pages</td>
<td>16-896 MB</td>
</tr>
<tr class="odd">
<td>ZONE<sub>HIGHMEM</sub></td>
<td>Dynamically mapped pages</td>
<td>&gt; 896 MBP</td>
</tr>
</tbody>
</table>
