#+SETUPFILE: ~/Documents/style.setup
#+STARTUP: align
#+LATEX_HEADER: \usepackage{ulem}
#+LATEX_HEADER: \usepackage{ctex}
#+LaTeX_HEADER: \sectionfont{\normalfont\scshape}
#+LaTeX_HEADER: \subsectionfont{\normalfont\itshape}
#+AUTHOR: whiothes

* Advanced Programming in the Unix Environment [76%]
** DONE Chapter 1. UNIX System Overview [12/12]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 1.1 Introduction
    操作系统为程序的运行提供服务。

*** DONE 1.2 UNIX Architecture
    * 内核：控制硬件资源和提供程序运行环境的软件
    * 系统调用：内核的接口层
    * 库：包含系统调用上层的常用函数
    * shell：为其它程序的运行提供接口的特殊秩序
    #+caption: Figure 1.1 Architecture of the UNIX operating system
    [[file:Chapter01/01fig01.jpg]]

*** DONE 1.3 Logging in
**** Login Name
     =/etc/passwd= 文件保存了用户信息

**** Shells
     #+caption: Figure 1.2 Common shells used on UNIX systems
     [[file:Chapter01/01fig02.jpg]]

*** DONE 1.4 Files and Directories
**** File System
     UNIX 文件是一个目录和文件的层级结构，从根目录 "/" 开始

     目录是一个包含了目录条目的文件, 逻辑上每个条目包含了文件名, 文件属性等信息结构.

***** Filename
      目录中的名字称为文件名.

***** Pathname
      - Example
        #+caption: Figure 1.3 List all the files in a directory
        #+include: "Chapter01/01fig03.c" src c

***** Working Directory
      当前所在目录

***** Home Directory
      设置的登录后所处的目录

*** DONE 1.5 Input and Output - File Descriptors
**** 文件描述符
     非负整数，被内核用以区分被进程访问的文件

***** Standard Input, Standard Output, and Standard Error
****** Unbuffered I/O
       由 ~open~, ~read~, ~write~, ~lseek~, ~close~ 函数提供
       - Example
         #+caption: Figure 1.4 Copy standard input to standard output
         #+include: "Chapter01/01fig04.c" src c

****** Standard I/O
       为无缓冲的 I/O 函数提供带缓冲的 I/O 接口。

       - Example
         #+caption: Figure 1.5 Copy standard input to standard output, using standard I/O
         #+include: "Chapter01/01fig05.c" src c

*** DONE 1.6 Programs and Processes
**** Program
     存在于磁盘上一个目录里的 *可执行* 文件
     读入内存后由内核使用 7 个 ~exec~ 函数之一执行

***** Proceses and Process ID
      一个运行中程序的实例称为进程。

      每一个进程都有一个独有的数字标识，称为 PID，一般为非负整数。

      - Example
        #+caption: Figure 1.6 Print the process ID
        #+include: "Chapter01/01fig06.c" src c

***** Process Control
      ~fork~, ~exec~, ~waitpid~

      - Example
        #+caption: Figure 1.7 Read commands from standard input and execute them
        #+include: "Chapter01/01fig07.c" src c

***** Threads and Thread IDs
      多线程用于多核系统的并发。

      线程 ID 与进程 ID 相似。
*** DONE 1.7 Error Handling
    当 UNIX 系统函数出现错误时，返回一个负值，errno 通常被设置为错误原因代码。

    <errno.h> 定义了 errno，并为每一个设想的错误定义了一个常数。


    多线程共享进程地址空间，会互相干扰，所以需要自己的 errno 备份。Linux 多线程访问 errno:
    #+begin_src c
      /* Linux 多线程访问 errno: */
      extern int *__errno_location(void);
      #define errno (*__errno_location())
    #+end_src

    关于 =errno= 需要注意以下两点：
    1. 如果没有发生错误， =errno= 也不会清除
    2. =errno= 的值不会被设为 0，<errno.h> 里也没有定义常数 0


    打印错误信息的函数
    #+begin_src c
      #include <string.h>

      /**
       ,* @brief      Print error messages
       ,* @return     pointer to message string
       ,*/
      char *strerror(int errnum);

      /**
       ,* @brief      print error messages
       ,*
       ,* @details    outputs the string pointed to by msg,
       ,*             followed by a colon and a space,
       ,*             followed by the error message corresponding to the value of errno,
       ,*             followed by a '\n'
       ,*/
      void perror(const char *msg);
    #+end_src

    - Example
      #+caption: Figure 1.8 Demonstrate strerror and perror
      #+include: "Chapter01/01fig08.c" src c

**** Error Recovery
     <errno.h> 内定义的错误可以分为：致命和非致命
     - 致命：退出并打印错误信息到文件或屏幕
     - 非致命：大多非致命错误都是暂时的，比如资源短缺，系统活动较少时可能不发生，通常延迟重试即可。

*** DONE 1.8 User identification
**** User ID
     保存在密码文件里的数字值，系统用以区分用户

     /root/ 或 /superuser/ 的 UID 是 0

**** Group ID
     类似 UID，用以区分用户属组，组文件为 /etc/group

     - Example
       #+caption: Figure 1.9 Print user ID and group ID
       #+include: "Chapter01/01fig09.c" src c

**** Supplementary Group IDs
     除了密码本文件中为用户名指定的 GID，多数 UNIX 系统版本允许一个用户归属其它组。

*** DONE 1.9 Signals
    Process choices:
    1.  Ignore
    2.  default action
    3.  provide call function (catch signal)


    - Example
      #+caption: Figure 1.10 Read commands from standard input and execute them
      #+include: "Chapter01/01fig10.c" src c

*** DONE 1.10 Time Values
    1. Calendar time. The value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970, UTC.
    2. Process time. CPU time, measures the central processor resources used by a process. in clock ticks. =clock_t=.
       - Clock time
       - User CPU time
       - System CPU time

*** DONE 1.11 System calls and Library Functions
    + Concepts:
      - System calls:
        - Unix 系统实现，定义明确且数量有限的接口
        - learned with ~man 2~ (Section 2 of /Unix Programmer's Mannual/)
        - 运行在内核
      - Library Functions:
        - These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls
        - Can be learned with ~man 3~ for *general-purpose* (Section 3 of /Unix Programmer's Mannual/)
    + Distinction:
      - the system calls usually cannot be replaced
      - the interface the UNIX system provides to determine the current time and date


    #+caption: Figure 1.11 Separation of ~malloc~ function and ~sbrk~ system call
    [[file:Chapter01/01fig11.jpg]]


    #+caption: Figure 1.12 Difference between C library functions and system calls
    [[file:Chapter01/01fig12.jpg]]

*** DONE 1.12 Summary
    - Exercises
      - 1.1
      - 1.2  53268 50922 was occupied
      - 1.3  strerror: int, value transfer, can not be changed, global errno can not be forecast
        perror: pointer, can be changed the value point to, const set constant
      - 1.4  2038,
        \( \frac{2^{31}}{(60*60*24*365)+1970} \)
        change time_t to u_64_t
        recompile the program

    - 1.5

    \( \frac{2^{31}}{(60*60*24*100)}=248.551348 \) days

** DONE Chapter 2. UNIX Standardization and Implementations [10/10]
*** DONE 2.1 Introduction
*** DONE 2.2 UNIX Standardization
**** DONE ISO C
**** DONE IEEE POSIX
**** DONE The Single UNIX Specification
     - Encryption: denoted by ~_XOPEN_CRYPE~
     - Real-time: denoted by ~_XOPEN_REALTIME~
     - Advanced real-time
     - Real-time threads: denoted by ~_XOPEN_REALTIME_THREADS~
     - Advanced real-time threads

**** DONE FIPS

*** DONE 2.3 UNIX System Implementations
**** DONE 2.3.1 UNIX system V Release 4
**** DONE 2.3.2 4.4BSD
**** DONE 2.3.3 FreeBSD
**** DONE 2.3.4 Linux
**** DONE 2.3.5 Mac OS X
**** DONE 2.3.6 Solaris
**** DONE 2.3.7 Others
     - AIX, IBMUNIX
     - HP-UX, HP
     - IRIX, Silicon Graphics
     - Unix Ware, SVR4 distribution

*** DONE 2.4 Relationship of Standards and Implementations

*** DONE 2.5 Limits
    1. Comipile-time limits
    2. Runtime limits


    编译时限制可以在头文件中定义，运行时限制需要进程调用一个函数以获取值。

    #+caption: Figure 2.6 Sizes of integral values from <limits.h>
    [[file:Chapter02/02fig06.jpg]]

    #+caption: Figure 2.7 ISO limits on various platforms
    [[file:Chapter02/02fig07.jpg]]

**** DONE 2.5.1 ISO C Limits
**** DONE 2.5.2 POSIX Limits
     1. Numerical limits: ~LONG_BIT~, ~SSIZE_MAX~, and ~WORD_BIT~
     2. Minimum value：Figure 2.8 中的 25 个常数
     3. Maximum value: ~_POSIX_CLOCKRES_MIN~
     4. Runtime increasable values: ~CHARCLASS_NAME_MAX~, ~COLL_WEIGHTS_MAX~, ~LINE_MAX~, ~NGROUPS_MAX~, and ~RE_DUP_MAX~
     5. Runtime invariant values: the 17 constants in Figure 2.9 (plus an additional four constants introduced in Section 12.2 and three constants introduced in Section 14.5)
     6. Other invariant values: ~NL_ARGMAX~, ~NL_MSGMAX~, ~NL_SETMAX~, and ~NL_TEXTMAX~;
     7. Pathname variables values: ~FILESIZEBITS~, ~LINK_MAX~, ~MAX_CANON~, ~MAX_INPUT~, ~NAME_MAX~, ~PATH_MAX~, ~PIPE_BUF~, and ~SYMLINK_MAX~


     #+caption: Figure 2.8 POSIX.1 minimum values from <limits.h>
     [[file:Chapter02/02fig08.jpg]]

     #+caption: Figure 2.9 POSIX.1 runtime invariant values from <limits.h>
     [[file:Chapter02/02fig09.jpg]]

     其中部分常量最小值太小而不实用，不带 *_POSIX_* 前缀的常量名给定了一个实现的实用值。

**** DONE 2.5.3 XSI Limits
     1. Minimum values: the five constants in Figure 2.10
     2. Runtime invariant values, possibly indeterminate: *IOV_MAX* and *PAGE_SIZE*

     #+caption: Figure 2.10 XSI minimum values from <limits.h>
     [[file:Chapter02/02fig10.jpg]]

**** DONE 2.5.4 ~sysconf~, ~pathconf~, and ~fpathconf~ Functions
     #+begin_src c
       /**
        ,* @brief      obtain runtime limits
        ,*
        ,* @details
        ,*
        ,* @param
        ,*
        ,* @return     corresponding value if OK, -1 on error
        ,*/
       #include <unistd.h>

       long sysconf(int name);

       long pathconf(const char *pathname, int name);

       long fpathconf(int fd, int name);
     #+end_src
     返回值细节
     1. 如果 /name/ 参数并非适当常量之一，函数返回 -1 并将 =errno= 设为 =EINVAL=
     2. 有些可以返回变量的值（>= 0）或返回值不确定，通过返回 -1 且不改变 =errno= 的值来表示
     3. =_SC_CLK_TCK= 返回每秒时钟滴答数，供时间函数的返回值使用（Section 8.17）


     有些限制适用于 ~pathconf~ 的/pathname/ 参数以及 ~fpathconf~ 的 /fd/ 参数：
     1. =_PC_MAX_CANON= 和 =_PC_MAX_INPUT= 的引用文件必须是终端文件
     2. =_PC_LINK_MAX= 和 =_PC_TIMESTAMP_RESOLUTION= 的引用文件可以是文件或目录。如果是目录，则返回值适用于目录本身，而非目录中的文件名。
     3. =_PC_FILESIZEBITS= 和 =_PC_NAME_MAX= 的引用文件必须是目录。返回值适用于目录中的文件。
     4. =_PC_PATH_MAX= 的引用文件必须是目录。
     5. =_PC_PIPE_BUF= 的引用文件必须是一个 pipe, FIFO 或目录。前两个是 pipe 或 FIFO 的限制值，如果是目录时，返回值是目录中的任意 FIFO 的限制
     6. =_PC_SYMLINK_MAX= 的引用文件必须是一个目录。返回值是该目录中可以包含的链接的最大字符串长度。

     #+caption: Figure 2.11 Limits and /name/ arguments to ~sysconf~
     [[file:Chapter02/02fig11.jpg]]

     #+caption: Figure 2.12 Limits and /name/ arguments to ~pathconf~ and ~fpathconf~
     [[file:Chapter02/02fig12.jpg]]

     #+caption: Figure 2.13 Build C program to print all supported configuration limits
     #+include: "Chapter02/makeconf.awk" src awk

     #+caption: Figure 2.14 Print all possible sysconf and pathconf values
     #+include: "Chapter02/02fig14.c" src c

     #+CAPTION: Figure 2.15 Examples of configuration limits
     [[file:Chapter02/02fig15.jpg]]

**** DONE 2.5.5 Indeterminate Runtime Limits
***** Pathnames
      =MAXPATHLEN=
      1.
      #+caption: pathalloc
      #+include: "lib/pathalloc.c" src c
      2.
      #+caption: openmax
      #+include: "lib/openmax.c" src c

*** DONE 2.6 Options
    1.  Compile-time options are defined in ~<unistd.h>~
    2.  Runtime options are not associated with a file or a directory are idnetified with the ~sysconf~ function
    3.  Runtime options that are associated with a file or a directory are discovered by calling either the ~pathconf~ or the ~fpathconf~ function

*** DONE 2.7 Features Test Macros
    ~cc -D_POSIX_C_SOURCE=200809L code.c~

*** DONE 2.8 Primitive System Data Types
    The header ~<sys/types.h>~ defines some implementation-dependent data types, called the /primitive system data types/.

*** DONE 2.9 Differences Between Standards
*** DONE 2.10 Summary
    - Exercises

      - 2.1  #ifndef ... #define ... #endif

      - 2.2  ~u_long, ushort, uint, u_quad_t, quad_t, qaddr_t, daddr_t, fixpt_t~

      - 2.3

        #+caption: OPEN_MAX exercise
        #+include: "Chapter02/ex02.c" src c

** DONE Chapter 3. File I/O [17/17]
   CLOSED: [2019-11-08 Fri 00:38]
   :PROPERTIES:
   :EXPORT_FILE_NAME: ./build/./build/./build/Chapter_3._File_I/O
   :END:

*** DONE 3.1 Introduction
*** DONE 3.2 File Descriptors
    To the kernel, all open file are referred to by file descriptors.

    - 0: stdin

    - 1: stdout

    - 2: stderr

*** DONE 3.3 ~open~ and ~openat~ Functions
    ~man 2 open~

*** DONE 3.4 ~creat~ Function
    ~man 2 creat~

*** DONE 3.5 ~close~ Function
    ~man 2 close~

*** DONE 3.6 ~lseek~ Function
    ~man 2 lseek~

    - Example

      #+caption: Figure 3.1 Test whether standard input is capable of seeking
      #+include: "Chapter03/seek.c" src c \\
    #+caption: Figure 3.2 Create a file with a hole in it
    #+include: "Chapter03/hole.c" src c

*** DONE 3.7 ~read~ Function
    ~man 2 read~

*** DONE 3.8 ~write~ Function
    ~man 2 write~

*** DONE 3.9 I/O Efficiency
    #+caption: Figure 3.5 Copy standard input to standard output
    #+include: "Chapter03/03fig05.c" src c

*** DONE 3.10 File Sharing
    1.  Every process has an entry in the process table.
    2.  The kernel maintains a file table for all open files.
    3.  Each open file(or device) has a v-node structure that contains information about the type of file \\
       and pointers to functions that operate on the file;

*** DONE 3.11 Atomic Operations
    - Appending to a File

    - ~pread~ and ~pwrite~ Functions

      Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.

      - There is no way to interrupt the two operations that occur when we call pread.

      - The current file offset is not updated.

    - Creating a File

      /atomic operation/ refers to an operation that might be composed of multiple steps

*** DONE 3.12 ~dup~ and ~dup2~ Functions
    ~man 2 dup~

    - ~dup(fd)~ ~ =fcntl(fd, F_DUPFD, 0)~

    - ~dup2(fd, fd2)= = =close(fd2); fcntl(fd, F_DUPFD, fd2);~

    Differences:

    - dup2 is an atomic operation, whereas the alternate form involves two function calls.

    - errno differences

*** DONE 3.13 ~sync~, ~fsync~ and ~fdatasync~ Functions
    ~man 2 sync~

*** DONE 3.14 ~fcntl~ Function
    #+begin_src c
      #include <fcntl.h>
      int fcntl(int fd, int cmd, ... /* int arg */);
      // Returns: dependos on cmd if OK (see following), -1 on error
    #+end_src
    The ~fcntl~ function is used for five different purposes.
    1.  Duplicate an existing descriptor (/cmd/ = =F_DUPFD= or =F_DUPFD_CLOEXEC=)
    2.  Get/set file descriptor flags (/cmd/ = =F_GETFD= or =F_SETFD=)
    3.  Get/set file status flags (/cmd/ = =F_GETFL= or =F_SETFL=)
    4.  Get/set asynchronous I/O ownership (/cmd/ = =F_GETOWN= or =F_SETOWN=)
    5.  Get/set record locks (/cmd/ = =F_GETLK=, =F_SETLK=, or =F_SETLKW=)

    - Example

      #+caption: Figure 3.11 Print file flags for specified descriptor
      #+include: "Chapter03/fileflags.c" src c \\
    #+caption: Figure 3.12 Turn on one or more of the file status flags for a descriptor
    #+include: "Chapter03/setfl.c" src c

*** DONE 3.15 ~ioctl~ Function
    =man 2 ioctl=

*** DONE 3.16 ~/dev/fd~
*** DONE 3.17 Summary
    - Exercises

      - 3.1  All disk I/O need to via buffer block.

        ~read/write~ always be buffered via kernel automatically, unbuffered only means user process;

      - 3.2

        #+include: "Chapter03/mydup2.c" src c

      - 3.3  F_SETFD: affect fd1 *file descriptor*

        F_SETFL: affect fd1 and fd2 *file table*

      - 3.4  without =if (fd > 2)=, there are 4 descriptors pointer to file, otherwise , there will be 3

      - 3.5  =./a.out > outfile 2>&1=: stdout => outfile, stderr => stdout => outfile

        =./a.out 2>&1 > outfile=: stderr => stdout, stdout => outfile \\

      - 3.6, can be read random, but cannot replace existing data;

        #+include: "Chapter03/ex06.c" src c

** DONE Chapter 4. System Data Files and Information [26/26]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 4.1 Introduction
*** DONE 4.2 ~stat~, ~fstat~, ~fstatat~, and ~lstat~ Functions
    =man 2 stat=

*** DONE 4.3 File Types
    1.  Regular file.
       There is no distinction to the UNIX kernel whether this data is text or binary.
    2.  Directory file.
    3.  Block special file.
    4.  Character special file.
       providing unbuffered I/O access.
    5.  FIFO.
    6.  Socket
    7.  Symbolic link.

    - Example

      #+caption: Figure 4.3 Print type of file for each command-line argument
      #+include: "Chapter04/filetype.c" src c

*** DONE 4.4 Set-User-ID and Set-Group-ID
    | IDs                     | using for                              |
    |-------------------------+----------------------------------------|
    | real user ID            | who we really are                      |
    | real group ID           |                                        |
    |-------------------------+----------------------------------------|
    | effective user ID       |                                        |
    | effective group ID      | used for file access permission checks |
    | supplementary group IDs |                                        |
    |-------------------------+----------------------------------------|
    | save set-user-ID        | saved by exec functions                |
    | save set-group-ID       |                                        |

*** DONE 4.5 File Access Permissions
    | st_mode mask | Meaning       |
    |--------------+---------------|
    | S_IRUSR      | user-read     |
    | S_IWUSR      | user-write    |
    | S_IXUSR      | user-execute  |
    |--------------+---------------|
    | S_IRGRP      | group-read    |
    | S_IWGRP      | group-write   |
    | S_IXGRP      | group-execute |
    |--------------+---------------|
    | S_IROTH      | other-read    |
    | S_IWOTH      | other-write   |
    | S_IXOTH      | other-execute |

*** DONE 4.6 Ownership of New Files and Directories
*** DONE 4.7 ~access~ and ~faccessat~ Functions
    =man 2 access=

    - Example

      #+caption: Figure 4.8 Example of access function
      #+include: "Chapter04/access.c" src c

*** DONE 4.8 ~umask~ Function
    =man 2 umask=

    - Example

      #+caption: Figure 4.9 Example of umask function
      #+include: "Chapter04/umask.c" src c

*** DONE 4.9 ~chmod~, ~fchmod~, and ~fchmodat~ Functions
    =man 2 chmod=

    - Example

      #+caption: Figure 4.12 Example of chmod function
      #+include: "Chapter04/changemod.c" src c

*** DONE 4.10 Sticky Bit
    If it was set for an executable program file, then the first time the program was executed, \\
    a copy of the program’s text was saved in the swap area when the process terminated

*** DONE 4.11 ~chown~, ~fchown~, ~fchownat~, and ~lchown~ Functions
    =man 2 chown=

*** DONE 4.12 File Size
    =struct stat.st_size=

*** DONE 4.13 File Truncation
    =man 2 truncate=

*** DONE 4.14 File Systems
    - Only when the link count goes to 0 can the file be deleted.

      =struct stat.st_nlink=

    - The other type of link is called a symbolic link. With a symbolic link, the actual contents of the file—the data blocks—store the name of the file that the symbolic link points to.

    - The i-node contains all the information about the file.

      Most of the information in the stat structure is obtained from the i-node, exclude *filename* and *i-node* number.

    - a directory entry can’t refer to an i-node in a different file system.

    - When renaming a file without changing file systems, the actual contents of the file need not be moved—all that needs to be done is to add a new directory entry that points to the existing i-node and then unlink the old directory entry.

*** DONE 4.15 ~link~, ~linkat~, ~unlink~, ~unlinkat~, and ~remove~ Functions
    =man 2 link=

    - Example

      #+caption: Figure 4.16 Open a file and then unlink it
      #+include: "Chapter04/unlink.c" src c

*** DONE 4.16 ~rename~ and ~renameat~ Functions
    =man 2 rename=
    1.  If oldname specifies a file that is not a directory, then we are renaming a file or a symbolic link.
    2.  If oldname specifies a directory, then we are renaming a directory.
    3.  If either oldname or newname refers to a symbolic link, then the link itself is processed, not the file to which it resolves.
    4.  We can’t rename dot or dot-dot.
    5.  As a special case, if oldname and newname refer to the same file, the function returns successfully without changing anything.

*** DONE 4.17 Symbolic Links
    - Hard links normally require that the link and the file reside in the *same file system*.

    - Only the superuser can create a hard link to a directory (when supported by the underlying file system).

*** DONE 4.18 Creating and Reading Symbolic Links
    =man 2 symlink=
    =man 2 readlink=

*** DONE 4.19 File Times
    #+caption: Figure 4.19 The three time values associated with each file
    | Field   | Description                    | Example      | ls(1) option) |
    |---------+--------------------------------+--------------+---------------|
    | st_atim | last-access of file data       | read         | -u            |
    | st_mtim | last-modification of file data | write        | default       |
    | st_ctim | last-change of i-node status   | chmod, chown | -c            |

*** DONE 4.20 ~futimens~, ~utimensat~, and ~utimes~ Functions
    POSIX.1
    =man 2 futimens=
    XSI
    =man 2 utimes=

    - Example

      #+caption: Figure 4.21 Example of futimens function
      #+include: "Chapter04/futimens.c" src c

*** DONE 4.21 ~mkdir~, ~mkdirat~, and ~rmdir~ Functions
    Creat4:
    =man 42 mkdir=
    Remov4e:
    =man 42 rmdir=.2 .2 .2 .2

*** DONE 4.22 Reading Directories
    =man 43 o pendir=

    - Exa4mpl e

      [[/4Use rs/zhoush/Private/Notes/books/c/APUE/Chapter04/ftw.c][Figure 4.22 Recursively descend a directory hierarchy, counting file types]].2 .2 .2

*** DONE 4.23 ~chidr~, ~fchdir~ and ~getcwd~ Functions
    =man 42 c hdir=

    - Exa4mpl e

      #+c4apt ion: Figure 4.23 Example of chdir function
      #+i4ncl ude: "Chapter04/chdir.c" src c
    =man 43 g etcwd=

    - Exa4mpl e

      #+c4apt ion: Figure 4.24 Example of getcwd function
      #+i4ncl ude: "Chapter04/getcwd.c" src c.2 .2 .2 .2 .2 .2 .2 .2

*** DONE 4.24 Device Special Files
    - Exa4mpl e

      #+c4apt ion: Figure 4.25 Print st_dev and st_rdev values
      #+i4ncl ude: "Chapter04/devrdev.c" src c.2 .2 .2

*** DONE 4.25 Summary of File Access Permission Bits
    S_IRW4XU  = S_IRUSR | S_IWUSR | S_IXUSR
    S_IRW4XG  = S_IRGRP | S_IWGRP | S_IXGRP
    S_IRW4XO  = S_IROTH | S_IWOTH | S_IXOTH.2 .2 .2

*** DONE 4.26 Summary
    - Exercises

      - 4.1

        #+include: "Chapter04/exercises/ex1.c" src c
        before modification: symbolic link
        after  modification: regular

      - 4.2  default permissions: =----------=

      - 4.3  ~cat~ get : Permission denied

      - 4.4  nothing changed.

      - 4.5  directory always shoud be entries for . and ..

        the size of symbolic link should be the size of the file contained in.

      - 4.6

        #+include: "Chapter04/exercises/ex6.c" src c

      - 4.7  default access permissions are different

      - 4.8  ~du~ check the file/directory/path space instead of disk , and may need path permissions.

      - 4.9  it's not the last link to the file.

      - 4.10  recursive depth number

      - 4.11

        #+include: "Chapter04/exercises/ex11.c" src c

      - 4.12  FTP

      - 4.13  ~stat~ first, set timespec array to current time that you expect not change, and the other to the value you want.

      - 4.14  access time is the last read time

        modify time is last received

      - 4.15  The change time isn't stored because, even if it was stored, you wouldn't be able to set it to the original time. You cannot cheat the change time, it is always based on when the inode data was actually changed.

        \\
        Depending on the utility (tar or cpio), you can tell it to keep the original access and/or modify times. For example, tar by default maintains the original modify time but you can use the -m switch to set it to extraction time. The access time is always set to extraction time.

      - 4.16

        #+include: "Chapter04/exercises/ex16.c" src c \\

      - 4.17

        #+include: "Chapter04/exercises/ex17.c" src c \\
        =unlink: Operation not permitted=

** DONE Chapter 5. Standard I/O Library [16/16]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 5.1 Introduction
    This library is specified by the ISO C standard because it has been implemented on many operating systems other than the UNIX System.

*** DONE 5.2 Streams and FILE Objects
    =man 3 fwide=

*** DONE 5.3 Standard Input, Standard Output and Standard Error
    ~STDIN_FILENO~, ~STDOUT_FILENO~, ~STDERR_FILENO~

*** DONE 5.4 Buffering
    Three types of buffering are provided:
    1.  Fully buffered. \\
       In this case, actual I/O takes place when the standard I/O buffer is filled.
    2.  Line buffered. \\
       In this case, the standard I/O library performs I/O when a newline character is encountered on input or output.
    3.  Unbuffered. \\

    ISO C requires the following buffering characteristics:

    - Standard input and standard output are fully buffered, if and only if they do not refer to an interactive device.

    - Standard error is never fully buffered.

    Most implementations default to the following types of buffering:

    - Standard error is always unbuffered.

    - All other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.

    =man 3 setbuf=
    =man 3 fflush=

*** DONE 5.5 Opening a Stream
    =man 3 fopen=
    =man 3 fclose=

*** DONE 5.6 Reading and Writing a Stream
    Three types of unformatted I/O:
    1.  Character-at-a-time I/O.
    2.  Line-at-a-time I/O.
    3.  Direct I/O.
    5.7 **** DONE Input Functions
    =man 3 getc=
    1.  The argument to getc should not be an expression with side effects, because it could be evaluated more than once.
    2.  Since fgetc is guaranteed to be a function, we can take its address. This allows us to pass the address of fgetc as an argument to another function.
    3.  Calls to fgetc probably take longer than calls to getc, as it usually takes more time to call a function.

    In most implementations, two flags are maintained for each stream in the FILE object:
    =man 3 ferror=

    - An error flag

    - An end-of file flagp

    After reading from a stream, we can push back characters by calling ~ungetc~.
    5.8 **** DONE Output Functions
    =man 3 putc=

*** DONE 5.9 Line-at-a-Time I/O
    =man fgets=

*** DONE 5.10 Standard I/O Efficiency
    #+caption: Figure 5.4 Copy standard input to output using getc and putc
    #+include: "Chapter05/cpio.c" src c \\
    #+caption: Figure 5.5 Copy standard input to output using fgets and fputs
    #+include: "Chapter05/cpio_1.c" src c

*** DONE 5.11 Binary I/O
    =man fread=

*** DONE 5.12 Positioning a Stream
    Three way to position a standard I/O stream:
    1.  ~ftell~ and ~fseek~
    2.  ~ftello~ and ~fseeko~
    3.  ~fgetpos~ and ~fsetpos~

    When porting applications to non-UNIX systems, use fgetpos and fsetpos.
    #+begin_src c
      #include <stdio.h>

      int fgetpos(FILE *restrict stream, fpos_t *restrict pos);

      int fseek(FILE *stream, long offset, int whence);

      int fseeko(FILE *stream, off_t offset, int whence);

      int fsetpos(FILE *stream, const fpos_t *pos);

      long ftell(FILE *stream);

      off_t ftello(FILE *stream);

      void rewind(FILE *stream);
    #+end_src

*** DONE 5.13 Formated I/O
    =man 3 printf=

    #+caption: Figure 5.7 The flags component of a conversion specification
    | Flag    | Description                                                                           |
    |---------+---------------------------------------------------------------------------------------|
    | /       | <>                                                                                    |
    | '       | [[file:Chapter05/formatted.c::printf("\nthousands grouping:\n");][(apostrophe) format integer with thousands grouping characters]]                        |
    | -       | [[file:Chapter05/formatted.c::printf("\nleft-justify:\n");][left justify]]                                                                          |
    | +       | [[file:Chapter05/formatted.c::printf("\nsigned decimal:\n");][always display sign of a signed conversion]]                                            |
    | (space) | [[file:Chapter05/formatted.c::printf("\nspace prefix:\n");][prefix by a space if no sign is generated]]                                             |
    | \#      | [[file:Chapter05/formatted.c::printf("\nalternative form:\n");][convert using alternative form(include 0x prefix for hexadecimal format, for example)]] |
    | 0       | [[file:Chapter05/formatted.c::printf("\nprefix zero:\n");][prefix with leading zeros instead of padding with spaces]]                              |

    #+caption: Figure 5.8 The lenth modifier component of a conversion specification
    | Length modifer | Description                               |
    |----------------+-------------------------------------------|
    | /              | <>                                        |
    | hh             | signed or unsigned char                   |
    | h              | sigend or unsigned short                  |
    | l              | signed or unsigned long or wide character |
    | ll             | signed or unsigned long long              |
    | j              | inmax_t or uintmax_t                      |
    | z              | size_t                                    |
    | t              | ptrdiff_t                                 |
    | L              | long double                               |

    #+caption: Figure 5.9 The conversion type component of a conversion specification
    | Conversion type | Description                                                                               |
    |-----------------+-------------------------------------------------------------------------------------------|
    | /               | <>                                                                                        |
    | d,i             | [[file:Chapter05/formatted.c::printf("\nsigned decimal:\n");][signed decimal]]                                                                            |
    | o               | [[file:Chapter05/formatted.c::printf("\nalternative form:\n");][unsigned octal]]                                                                            |
    | u               | [[file:Chapter05/formatted.c::printf("\nunsigned decimal:\n");][unsigned decimal]]                                                                          |
    | x,X             | [[file:Chapter05/formatted.c::printf("\nunsigned hexadecimal:\n");][unsigned hexadecimal]]                                                                      |
    | f,F             | [[file:Chapter05/formatted.c::printf("\ndouble floating-point number:\n");][double floating-point number]]                                                              |
    | e,E             | [[file:Chapter05/formatted.c::printf("\nexponential format:\n");][double floating-point number in exponential format]]                                        |
    | g,G             | [[file:Chapter05/formatted.c::printf("\ninterpreted:\n");][interpreted as f, F, e, or E, depending on value converted]]                                |
    | a,A             | [[file:Chapter05/formatted.c::printf("\ndouble in hexadecimal:\n");][double floating-point number in hexadecimal exponential format]]                            |
    | c               | character (with 1 length modifier, wide character)                                        |
    | s               | string(with 1 length modifier, wide character string)                                     |
    | p               | pointer to a void                                                                         |
    | n               | pointer to a signed integer into which is written the number of characters written so far |
    | %               | a % character                                                                             |
    | C               | wide chracter(XSI option, equivalent to lc)                                               |
    | S               | wide chracter string(XSI option, equivalent to ls)                                        |

    *Formatted Input*
    =man 3 scanf=
    #+caption: Figure 5.9 The conversion type component of a conversion specification
    | Conversion type | Description                                                                               |
    |-----------------+-------------------------------------------------------------------------------------------|
    | /               | <>                                                                                        |
    | d               | signed decimal, base 10                                                                   |
    | i               | signed decimal, base determined by format of input                                        |
    | o               | unsigned octal(input optionally signed)                                                   |
    | u               | unsigned decimal, base 10(input optionally signed)                                        |
    | x,X             | unsigned hexadecimal(input optionally signed)                                             |
    | a,A,e,E,f,F,g,G | floating-point number                                                                     |
    | c               | character (with 1 length modifier, wide character)                                        |
    | s               | string(with 1 length modifier, wide character string)                                     |
    | [               | mathches a sequence of listed characters, ending with ]                                   |
    | [^              | mathches all characters except the ones listed, ending with ]                             |
    | p               | pointer to a void                                                                         |
    | n               | pointer to a signed integer into which is written the number of characters written so far |
    | %               | a % character                                                                             |
    | C               | wide chracter(XSI option, equivalent to lc)                                               |
    | S               | wide chracter string(XSI option, equivalent to ls)                                        |

    ***

*** DONE 5.14 Implementation Details
    =man 3 fileno=

    - Example

      #+caption: Figure 5.11 Print buffering for various standard I/O streams
      #+include: "Chapter05/print.c" src c

*** DONE 5.15 Temporary Files
    =man 3 tmpnam=

    - Example

      #+caption: Figure 5.12 Demonstrate tmpnam and tmpfile functions
      #+include: "Chapter05/tmpnam.c" src c

    =man 3 mkdtemp=

    - Example

      #+caption: Figure 5.13 Demonstrate mkstemp function
      #+include: "Chapter05/mkdtemp.c" src c

*** DONE 5.16 Memory Streams
    =man 3 fmemopen=

    - Example

      #+caption: Figure 5.15 Investigate memory stream write behavior
      #+include: "Chapter05/memopen.c" src c \\
    *linux* result:
    #+begin_quote
    initial buffer contents: \\
    before flush: \\
    after fflush: hello, world \\
    len of string in buf = 12 \\
    after fseek: hello, world \\
    len of string in buf = 24 \\
    after fclose: hello, world \\
    len of string in buf = 46
    #+end_quote

    The other two functions:
    =man open_memstream=

*** DONE 5.17 Alternatives to Standard I/O
    The standard I/O library is not perfect. some in the basic design, but most in the various implementations.

*** DONE 5.18 Summary
    - Exercises

      - 3.1

        #+include: "Chapter05/exercises/ex1.c" src c

      - 3.2

        #+include: "Chapter05/exercises/ex2.c" src c \\
        execute ~fgets~ and ~fputs~ more than 1 times;

      - 3.3  print nothing

      - 3.4  This is a common error. The return value from getc and getchar is an int, not a char. EOF is often defined to be −1, so if the system uses signed characters, the code normally works

      - 3.5  call ~fflush~ first

      - 3.6  stdin and stdout are both line buffered. fgets will fflush automatically

      - 3.7

        #+include: "Chapter05/exercises/funopen-fmemopen.c" src c

** DONE Chapter 6. System Data Files and Information [11/11]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 6.1 introduction
*** DONE 6.2 Password File
    =man getpwuid=

*** DONE 6.3 Shadow Passwords
    *On Linux 3.2.0 and Solaris 10,*
    =man getspnam=
    *On FreeBSD 8.0 and Mac OS X 10.6.8, there is no shadow password structure*

*** DONE 6.4 Group File
    =man getgrgid=

*** DONE 6.5 Supplementary Group Ids
    =man getgroups= \\

    - Example

      #+caption: Example for get groups' info
      #+include: "Chapter06/getgropus.c" src c

*** DONE 6.6 Implementation Differences
*** DONE 6.7 Other Data Files
    at least three functions:
    1.  A get function that reads the next record, opening the file if necessary.
    2.  A set function that opens the file, if not already open, and rewinds the file.
    3.  An end entry that closes the data file.

*** DONE 6.8 Login Accounting
    #+begin_src c
      struct utmp {
              char ut_line[8]; /* tty line: "ttyh0", "ttyd0", "ttyp0", ... */
              char ut_name[8]; /* login name */
              long ut_time; /* seconds since Epoch */
      };
    #+end_src

    login: filled in and written to te utmp file, and appended to the wtmp file by the login program.
    logout: utmp file was filled with null bytes by the init process, and a new entry was appended to the wtmp file.

    ~who~ reads utmp file
    ~last~ reads wtmp file

*** DONE 6.9 System Identification
    information on the current host and operating system.
    #+begin_src c
      #include <sys/utsname.h>
      int uname(struct utsname *name);
      // Returns: non-negative value if OK, -1 on error
    #+end_src

    network hostname:
    #+begin_src c
      #include <unistd.h>
      int gethostname(char *name, int namelen);
      // Returns: 0 if OK, -1 on error
    #+end_src

*** DONE 6.10 Time and Date Routines
    =man 3 time=
    =man 3 clock_gettime=
    =man 3 gmtime=
    =man 3 strftime=

    - Example

      #+caption: Figure 6.11 Using the strftime function
      #+include: "Chapter06/strftime.c" src c \\
    =man 3 strptim=

*** DONE 6.11 Summary
    - Exercises

      - 6.1  On Mac OS, I can't get it

        On Linux, use ~getsnam~ group functions

      - 6.2

        #+include: "Chapter06/exercises/getspnam.c" src c

      - 6.3

        #+include: "Chapter06/exercises/uname.c" src c, equivalent

      - 6.4 32-bit time: =1970 + (2^{31}/60/60/24/365)=

        after pass : =1970 - (2^{31}/60/60/24/365)=

      - 6.5

        #+include: "Chapter06/exercises/time.c" src c

** DONE Chapter 7. Process Environment [11/11]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 7.1 Introduction
*** DONE 7.2 main Function
    #+begin_src C
      int main(int argc, char *argv[]);
    #+end_src

*** DONE 7.3 Process Termination
    There are eight ways for a process to terminate.
    Normal termination occurs in five ways:
    1.  Return from main
    2.  Calling ~exit~
    3.  Calling ~_exit~ or ~_Exit~
    4.  Return of the last thread from its start routine (Section 11.5)
    5.  Calling pthread_exit (Section 11.5) from the last thread

    Abnormal termination occurs in three ways
    1.  Calling abort
    2.  Receipt of a signal
    3.  Response of the last thread to a cancellation request

**** DONE Exit Functions
     =man 3 exit=
     =man 2 _exit=
     #+begin_src c
       #include <stdio.h>
       void exit(int status);
       // 1. call the functions registered with atexit(3) function, in the reverse order of their registration
       // 2. Flush all open output streams
       // 3. close all open streams
       // 4. unlink all files created with the tmpfile functions

       void _Exit(int status);
       // terminates without calling functions registered with atexit(3),
       // may or my not perform the other actions listed

       #include <unistd.h>
       void _exit(int status);
       // The _exit() function terminates a process, with the following consequences:
       // o   All of the descriptors that were open in the calling process are closed.  This may entail delays; for example, waiting for output to drain.  A process in this state may not be
       //     killed, as it is already dying.
       //
       // o   If the parent process of the calling process has an outstanding wait call or catches the SIGCHLD signal, it is notified of the calling process's termination; the status is set as
       //     defined by wait(2).
       //
       // o   The parent process-ID of all of the calling process's existing child processes are set to 1; the initialization process (see the DEFINITIONS section of intro(2)) inherits each of
       //     these processes.
       //
       // o   If the termination of the process causes any process group to become orphaned (usually because the parents of all members of the group have now exited; see ``orphaned process
       //     group'' in intro(2)), and if any member of the orphaned group is stopped, the SIGHUP signal and the SIGCONT signal are sent to all members of the newly-orphaned process group.
       //
       // o   If the process is a controlling process (see intro(2)), the SIGHUP signal is sent to the foreground process group of the controlling terminal.  All current access to the control-
       //     ling terminal is revoked.
     #+end_src
     ~_exit~ does not perform any flushing of standard I/O buffers.

     - Example

       #+begin_src c

       #+end_src
       #+caption: Figure 7.1 Classic C program
       #+include: "Chapter07/hello.c" src c

**** DONE ~atexit~ Function
     =man 3 atexit=
     The ~exit~ function calls these functions in reverse order of their registration.

     - Example

       #+caption: Figure 7.3 Example of exit handlers
       #+include: "Chapter07/atexit.c" src c

**** DONE Commond-Line Arguments
     - Example

       #+caption: Figure 7.4 Echo all command-line arguments to standard output
       #+include: "Chapter07/echoarg.c" src c

*** DONE 7.5 Environment List
    #+begin_src c
      extern char **environ;
    #+end_src

*** DONE 7.6 Memory Layout of a C Program
    #+name: Figure 7.6 Typical memory arrangement
    #+begin_src  plantuml :file "Chapter07/07fig06.jpg" :cmdline -charset utf-8
      rectangle obj as "
      <high address>

      ----

      stack
      ....
      ⭣

      ⭡
      ....
      heap

      ----

      uninitialized data(bss)

      ----

      initialized data

      ----

      <low address> text
      "
    #+end_src

    #+RESULTS: Figure 7.6 Typical memory arrangement
    [[file:Chapter07/07fig06.jpg]]

    Historically, a C program has been composed of the following pieces:

    - Text segment: consisting of the machine instructions that the CPU executes.

    - Initilized data segment, usually called simply the data segment,

      containing variables that are specifically initialized in the program.\\
      For example:
      #+begin_src c
        int maxcount=99;
      #+end_src

    - Uninitilized data segment, often called the “bss” segment,

      named after an ancient assembler operator that stood for “block started by symbol.”
      #+begin_src c
        long sum[1024];
      #+end_src

    - Stack, where automatic variables are stored,

      along with information that is saved each time a function is called.

    - Heap, where dynamic memory allocation usually takes place.

      #+begin_src c
        malloc();
      #+end_src

*** DONE 7.7 Shared Libraries
    without shared libraries
    #+begin_src bash
      gcc -static hello.c
      size a.out
      text     data     bss     dec     hex	filename
      723103     7284    6392  736779   b3e0b	a.out
    #+end_src
    use shared libraries, the text and data size are greatly decreased
    #+begin_src bash
      gcc hello.c
      size a.out
      text     data     bss     dec     hex	filename
      1173      552       8    1733     6c5	a.out
    #+end_src

*** DONE 7.8 Memory Allocation
    =man 3 malloc=
    1. ~malloc~, allocates specified number of bytes of memory without initialized
    2. ~calloc~, allocates specified number of bytes of memroy with initializing to 0
    3. ~realloc~, increase or decrease the size of previous allocated area, the increased area was not initialized

    #+begin_src c
      #include <stdlib.h>
      void *malloc(size_t size);
      void *calloc(size_t nobj, size_t size);
      void *realloc(void *ptr, size_t newsize);

      void free(void*ptr);
    #+end_src

    - Alternative Memory Allocators

      - ~jemalloc~

        designed to scale well when used with multithreaded applications running on multiprocessor systems.

      - ~TCMalloc~

        for high performance, scalability, and memory efficiency.

      - ~alloca~ Function

        alloc memmory from stack, instaead of heap, so we don't have to free the space;

*** DONE 7.9 Environment Variable
    =man 3 getenv=
    #+begin_src c
      #include <stdlib.h>
      char *getenv(const char *name);
      int putenv(char *str);
      int setenv(const char *name, const char *value, int rewrite);
      int unsetenv(const char *name);
    #+end_src

    *malloc*

*** DONE 7.10 ~setjmp~ and ~longjmp~ Functions
    - *useful for dealing errors and interrupts*

    - Example

      #+caption: Figure 7.9 Typical program skeleton for command-processing
      #+include: "Chapter07/cmd_add.c" src c \\

    =man 3 setjmp=

    - Example

      #+caption: Figure 7.13 Effect of longjmp on various type of variables
      #+include: "Chapter07/testjmp.c" src c

    - *Automatic, Register and Volatile Variables*

      Most implementations do not try to roll back these automatic variables and register variables, but the standards say only that their values are indeterminate

    *Potential Problem with Automatic Variables*
    #+caption: Figure 7.14 Incorrect usage of an automatic variable
    #+include: "Chapter07/incorrect_usage.c" src c
    #+begin_quote
    The problem is that when open_data returns, the space it used on the stack will be used by the stack frame for the next function that is called. But the standard I/O library will still be using that portion of memory for its stream buffer. Chaos is sure to result. To correct this problem, the array databuf needs to be allocated from global memory, either statically (static or extern) or dynamically (one of the alloc functions)
    #+end_quote

*** DONE ~getrlimit~ and ~setrlimit~ Functions
    =man 3 getrlimit=

    - Example

      #+caption: Figure 7.16 print the current resource limits
      #+include: "Chapter07/rlimit.c" src c

*** DONE Summary
    - Exercises

      1. the length of "hello, world"
      2. =man 3 exit=
      3. Nope
      4. *for NULL usage*
      5. =typedef void Exitfunc(void);= \\
         =int atexit(Exitfunc *func);=
      6. Yep, not sure
      7. the heap and stack aren't allocated before applying
      8. a.out include symbol info
      9. standard I/O library was copied
      10. Nope. num in heap

** DONE Chapter 8. Process Control [18/18]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 8.1 Introduction
*** DONE 8.2 Process Identifiers
    Process ID 0 is usually the scheduler process and is often know as /swapper/.
    Process ID 1 is usually the *init* process.
    responsible for bring up a UNIX system after the kernel has been bootstrapped
    Process ID 2 is pagedaemon.
    responsible for supporting paging of virtual memory system.

    =man 2 getpid=
    #+begin_src c
      #include <unistd.h> pid_t getpid(void);
      // Returns: process ID of calling process

      pid_t getppid(void);
      // Returns: parent process ID of calling process

      uid_t getuid(void);
      // Returns: real user ID of calling process

      uid_t geteuid(void);
      // Returns: effective user ID of calling process

      gid_t getgid(void);
      // Returns: real group ID of calling process

      gid_t getegid(void);
      // Returns: effective group ID of calling process
    #+end_src

    #+begin_quote
    Note that none of these functions has an error return.
    #+end_quote

*** DONE 8.3 ~fork~ Function
    =man 3 fork=
    #+BEGIN_SRC c
      pid_t fork(void);
      // Returns: 0 in child, process ID of child in parent, −1 on error
    #+END_SRC

    #+BEGIN_QUOTE
    called once but return twice.

    return value in child is 0, whereas the return value in the parent is the process ID of the new child

    the child gets a copy of the parent’s data space, heap, and stack, parents and child do not share memmory
    #+END_QUOTE

    - Example

      #+caption: Figure 8.1 Example of fork function
      #+include: "Chapter08/fork.c" src c \\
    *changes to variables in a child process do not affect the value of the variables in the parent process.*

    - File Sharing

      handling the descriptors after a fork.
      1. The parent waits for the child to complete.
      2. Both the parent and the child go their own ways. after fork, close needless descriptors(*socket*)

    - inherits:

      - Real user ID, real group ID, effective user ID, and effective group ID

      - Supplementary group IDs

      - Process group ID

      - Session ID

      - Controlling terminal

      - The set-user-ID and set-group-ID flags

      - Current working directory

      - Root directory

      - File mode creation mask

      - Signal mask and dispositions

      - The close-on-exec flag for any open file descriptors

      - Environment

      - Attached shared memory segments

      - Memory mappings

      - Resource limits

    - differences

      - return value

      - process id

      - parent id

      - child's tms_utime, tms_stime, tms_cutime, tms_cstime set to 0

      - parent's file locks are not inherited

      - pending alarms are cleared for the child

      - pending signals set is set to empty for child

    - There are two uses for fork:

      #+begin_quote
      1. When a process wants to duplicate itself so that the parent and the child can each execute different sections of code at the same time.
      2. When a process wants to execute a different program.
      #+end_quote

*** DONE 8.4 ~vfork~ Function
    #+begin_quote
    just like fork, without copying the address space of the parent into the child, as the child won’t reference that address space

    the child runs in the address space of the parent until it calls either exec or exit.

    *vfork guarantees that the child runs first, until the child calls exec or exit.*
    #+end_quote

    - Example

      #+caption: Figure 8.3 Example of vfork function
      #+include: "Chapter08/vfork.c" src c

*** DONE 8.5 ~exit~ Function
    #+begin_quote
    As we described in Section 7.3, a process can terminate normally in five ways:
    1.  Executing a return from the main function.
    2.  Calling the exit function.
    3.  Calling the _exit or _Exit function. *terminate without running exit handlers or signal handlers.*
    4.  Executing a return from the start routine of the last thread in the process.
    5.  Calling the pthread_exit function from the last thread in the process.
    #+end_quote

    #+begin_quote
    The three forms of abnormal termination are as follows:
    1.  Calling abort. generates *SIGABRT* signal
    2.  When the process receives certain signals.
    3.  The last thread responds to a cancellation request.
    #+end_quote

    #+begin_quote

- In UNIX System terminology, a process that has terminated, but whose parent has not yet waited for it, is called a zombie.

- The ps(1) command prints the state of a zombie process as Z.

    #+end_quote

*** DONE 8.6 ~wait~ and ~waitpid~ Functions
    #+begin_quote
    we need to be aware that a process that calls wait or waitpid can

    - Block, if all of its children are still running

    - Return immediately with the termination status of a child, if a child has terminated and is waiting for its termination for its termination status to be fetched

    - Return immediately with an error, if it doesn't have any child processes

    #+end_quote

    =man 2 wait=
    #+begin_src c
      #include <sys/wait.h>
      pid_t wait(int *statloc);
      pid_t waitpid(pid_t pid, int *statloc, int options);

      Both return: process ID if OK, 0(see later), or -1 on error
    #+end_src

    - Example

      #+caption: Figure 8.5 Print a description of the exit status
      #+include: "Chapter08/exit_status.c" src c \\
      #+caption: Figure 8.6 Demonstrate various exit status
      #+include: "Chapter08/exit.c" src c

    #+begin_quote
    The waitpid function provides three features that aren’t provided by the wait function.
    1.  The waitpid function lets us wait for one particular process, whereas the wait function returns the status of any terminated child.
    2.  The waitpid function provides a nonblocking version of wait.
    3.  The waitpid function provides support for job control with the WUNTRACED and WCONTINUED options.
    #+end_quote

    - Example

      #+caption: Figure 8.8 Avoid zombie processes by calling fork twice
      #+include: "Chapter08/waitpid.c" src c

*** DONE 8.7 ~waitid~ Function
    =man 2 waitid=
    #+begin_src c
      #include <sys/wait.h> int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
      // Returns: 0 if OK, −1 on error
    #+end_src
    (OS X can't get the info, but the function is valid)

*** DONE 8.8 ~wait3~ and ~wait4~ Functions
    =man 2 wait3=

*** DONE 8.9 Race Conditions
    *Avoid race by signal*

    - Example

      #+caption: Figure 8.12 Program with a race condition
      #+include: "Chapter08/race.c" src c \\
      #+caption: Figure 8.13 Modification of Figure 8.12 to avoid race condition
      #+include: "Chapter08/avoid_race.c" src c

*** DONE 8.10 ~exec~ Functions
    =man 3 exec=
    #+begin_src c
      #include <unistd.h>
      int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );
      int execv(const char *pathname, char *const argv[]);
      int execle(const char *pathname, const char *arg0, ...
                 /* (char *)0, char *const envp[] */ );
      int execve(const char *pathname, char *const argv[], char *const envp[]);
      int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );
      int execvp(const char *filename, char *const argv[]);
      int fexecve(int fd, char *const argv[], char *const envp[]);
    #+end_src
    Returns: All seven return: −1 on error, no return on success

    #+begin_quote
    The first difference in these functions is that the first four take a pathname argument, the next two take a filename argument, and the last one takes a file descriptor argument. When a filename argument is specified,

    - If filename contains a slash, it is taken as a pathname.

    - Otherwise, the executable file is searched for in the directories specified by the *PATH* environment variable.

    #+end_quote

    ~execlp~ and ~execvp~ assume *link* as a *shell script*, and try to invoke ~/bin/sh~ with *filename*

    #+begin_quote
    The letter *p* means that the function takes a filename argument and uses the PATH environment variable to find the executable file
    The letter *l* means that the function takes a list of arguments and is mutually exclusive
    The letter *v*, means that it takes an argv[] vector.
    Finally, the letter *e* means that the function takes an envp[] array instead of using the current environment.
    #+end_quote

    #+CAPTION: Figure 8.14 Differences among the seven exec functions
    [[file:Chapter08/08fig14.jpg]]

    #+CAPTION: Figure 8.15 Relationship of the seven exec functions
    [[file:Chapter08/08fig15.jpg]]

    - Example

      #+caption: Figure 8.16 Example of exec functions
      #+include: "Chapter08/exec.c" src c \\
      #+caption: Figure 8.17 Echo all command-line arguments and all environment strings
      #+include: "Chapter08/echo_env.c" src c

*** DONE 8.11 Changing User IDs and Group IDs
    =man 2 setuid=
    #+begin_quote
    1. If the process has superuser privileges, the setuid function sets the real user ID, effective user ID, and saved set-user-ID to uid.

    2. If the process does not have superuser privileges, but uid equals either the real user ID or the saved set-user-ID, setuid sets only the effective user ID to uid. The real user ID and the saved set-user-ID are not changed.

    3. If neither of these two conditions is true, errno is set to EPERM and −1 is returned.
    #+end_quote
    #+caption: Figure 8.18 Ways to change the three user IDs
    file:Chapter08/08fig18.jpg
    =man 2 setreuid=
    =man 2 setregid=

*** DONE 8.12 Interpreter Files
    - Example

      #+caption: Figure 8.20 A program that execs an interpreter file
      #+include: "Chapter08/exec_intr.c" src c \\
      #+caption: Figure 8.21 An awk program as an interpreter file
      #+include: "Chapter08/awkexample" src c

*** DONE 8.13 ~system~ Function
    #+begin_src c
      #include <stdlib.h>
      int system(const char *cmdstring);
    #+end_src
    *if /cmdstring/ is a ~NULL~, ~system~ returns nonzero only if a command processor is available.
    #+begin_quote
    1. If either the fork fails or waitpid returns an error other than EINTR, system returns −1 with errno set to indicate the error.

    2. If the exec fails, implying that the shell can’t be executed, the return value is as if the shell had executed exit(127).

    3. Otherwise, all three functions—fork, exec, and waitpid—succeed, and the return value from system is the termination status of the shell, in the format specified for waitpid.
    #+end_quote

    - Example

      #+caption: Figure 8.22 The system function, without signal handling
      #+include: "Chapter08/08fig22.c" src c
      #+caption: Figure 8.23 Calling the system function
      #+include: "Chapter08/08fig22.c" src c

    #+begin_quote
    The advantage in using system, instead of using fork and exec directly, is that system does all the required error handling and (in our next version of this function in Section 10.18) all the required signal handling.
    #+end_quote

    *Set-User-ID Programs*
    #+caption: Figure 8.24 Execute the command-line argument using system
    #+include: "Chapter08/systest.c" src c

    #+caption: Figure 8.25 Print real and effective user IDs
    #+include: "Chapter08/pruids.c" src c

*** DONE 8.14 Process Accounting
    - Example

      #+caption: Figure 8.28 Program to generate accounting data
      #+include: "Chapter08/acct_data.c" src c \\
      #+caption: Figure 8.29 Print select fields from system's accounting file
      #+include: "Chapter08/print_sel_acct.c" src c

*** DONE 8.15 User Identification
    =man 2 getlogin=
    #+caption: getlogin
    #+include: "Chapter08/getlogin.c" src c

*** DONE 8.16 Process Scheduling
    Lower nice values have higher scheduling priority.

    =man 3 nice=
    =man 3 getpriority=

    - Example

      #+caption: Figure 8.30 Evaluate the effect of changing the nice value
      #+include: "Chapter08/08fig30.c" src c

*** DONE 8.17 Process Times
    #+begin_src c
      #include <sys/times.h>
      clock_t times(struct tms *buf);

      // Returns: elapsed wall clock time in clock ticks if OK, -1 on error
    #+end_src
    #+caption: Figure 8.31 Time and execute all command-line arguments
    #+include: "Chapter08/pr_times.c" src c

*** DONE 8.18 Summary
    functions to master: ~fork~, ~exec~ family, ~_exit~, ~wait~ and ~waitpid~.

    ~fork~ function gave us an opportunity to look at race conditions.

    - Exercises

      -

        #+caption: 8.1
        #+include: "Chapter08/08ex01.c" src c

      -

        #+caption: 8.2
        #+include: "Chapter08/08ex02.c" src c

      -

        #+caption: 8.3
        #+include: "Chapter08/08ex01.c" src c

      - 8.4

    In Figure 8.13, we have the parent write its output first. When the parent is done, the child writes its output, but we let the parent terminate. Whether the parent terminates or whether the child finishes its output first depends on the kernel’s scheduling of the two processes (another race condition). When the parent terminates, the shell starts up the next program, and this next program can interfere with the output from the previous child.
    We can prevent this from happening by not letting the parent terminate until the child has also finished its output. Replace the code following the fork with the following:
    #+begin_src c
      else if (pid ~~ 0) {
              WAIT_PARENT(); /* parent goes first */
              charatatime("output from child\n");
              TELL_PARENT(getppid()); /* tell parent we’re done */
      } else {
              charatatime("output from parent\n");
              TELL_CHILD(pid);
              /* tell child we’re done */
              WAIT_CHILD(); /* wait for child to finish */
      }
    #+end_src
    We won’t see this happen if we let the child go first, since the shell doesn’t start the next program until the parent terminates.

    - 8.5 The same value

    -

      #+caption: 8.6
      #+include: "Chapter08/08ex06.c" src c

** DONE Chapter 9. Process Relationships [12/12]
   CLOSED: [2019-12-14 Sat 17:54]

*** DONE 9.1 Introduction
*** DONE 9.2 Terminal Logins
    CLOSED: [2019-11-08 Fri 09:48]

    - BSD Terminal Logins

      #+caption: Figure 9.1 Processes invoked by init to allow terminal logins
      [[file:Chapter09/9fig1.jpg][file:Chapter09/09fig01.jpg]]
      #+begin_quote
      a real user ID of 0 and an effective user ID of 0
      #+end_quote

      =login= program similar to
      #+begin_src c
        execle("/bin/login", "login", "-p", username, (char *)0, envp);
      #+end_src

*** DONE 9.3 Network Logins
    CLOSED: [2019-12-01 Sun 23:56]
    #+begin_quote
    The main (physical) difference between logging in to a system through a serial terminal and logging ni to a system through a network is that the connection between the terminal and the computer isn't point-to-point.

    To allow the same software to process logins over both terminal logins and network logins, a software driver called a pseudo terminal is used to emulate the behavior of a serial terminal and map terminal operations to network operations, and vice versa.
    #+end_quote

*** DONE 9.4 Process Groups
    CLOSED: [2019-12-02 Mon 00:04]
    #+name: each process belongs to a process group.
    #+begin_src c
      #include <unistd.h>
      pid_t getpgrp(void);
      // Returns: process group ID of calling process
    #+end_src
    #+name: in older BSD-derived systems:
    #+begin_src c
      #include <unistd.h>
      pid_t getpgid(pid_t pid);
      // Returns: process group ID if OK, -1 on error
    #+end_src

    ~getpgid(0) == getpgrp()~

    #+name: A process joins an existing process group or create a new process group:
    #+begin_src c
      #include <unistd.h>
      int setpgid(ipd_t pid, pid_t pgid);
      // Returns: 0 if OK, -1 on error
    #+end_src
    if /pid == pgid/, the pid becomes a process group leader
    if /pid == 0/, the process ID of the caller is used.
    if /pgid == 0/, the process ID specified by pid is used as process group ID

*** DONE 9.5 Sessions
    CLOSED: [2019-12-02 Mon 15:00]
    #+begin_quote
    A session is a collection of one or more process groups.
    #+end_quote

    #+name: establish a new session
    #+begin_src c
      #include <unistd.h>
      pid_t setsid(void);
      // Returns: process group ID if OK, -1 on error
    #+end_src
    1. The process becomes the /session leader/ of this new session. (A session leader is the process that creates a session)
    2. The process becomes the process group leader of a new process group.
    3. The process has no controlling terminal.

    #+name: return the process group ID of a process's session leader
    #+begin_src c
      #include <unistd.h>
      pid_t getsid(pid_t pid);
      // Returns: session leader's process group ID if OK, -1 on error
    #+end_src

*** DONE 9.6 Controlling Terminal
    CLOSED: [2019-12-02 Mon 16:05]
    Sessions and progress groups have a few other characteristics

    - A session can have a single /controlling terminal/.

    - The session leader that establishes the connection to the controlling terminal

    - The process groups within a session can be divided into a single /foreground process group/ and one or more /background proces groups/

    - If a session has a controlling terminal, it has a single foreground process group and all other process groups in the session are background process groups

    - Whenever we press the terminal's interrupt key(often DELETE or Control-C), the interrupt signal is sent to all processes in the foreground process group.

    - Whenever we press the terminal's quit key(Often Control-backslash), the quit signal is sent to all processes in the foreground process group.

    - If a modem(or network) disconnect is detected by the terminal interface, the hang-up signal is sent to the controlling process (the session leader).

*** DONE 9.7 ~tcgetpgrp~, ~tcsetpgrp~, and ~tcgetsid~ Functions
    CLOSED: [2019-12-04 Wed 19:04]
    #+name: get/set process group ID for foreground process group
    #+begin_src c
      #include <unistd.h>
      pid_t tcgetpgrp(int fd);
      // Returns: process group ID of foreground process group if OK, -1 on error

      int tcsetpgrp(int fd, pid_t pgrpid);
      // Returns: 0 if OK, -1 on error
    #+end_src

    #+name: allow application to obtain the process group ID for the session leader given a file descriptor for the controlling TTY.
    #+begin_src c
      #include <termios.h>
      pid_t tcgetsid(int fd);
      // Returns: session leader's process group ID if OK, -1 on error
    #+end_src

*** DONE 9.8 Job Control
    CLOSED: [2019-12-07 Sat 00:53]
    Requirements:
    1. A shell that supports job control
    2. The terminal driver in the kernel must support job control
    3. The kernel must support certain job-control signals

    #+begin_src sh
      cat > temp.foo & # & let start in background
      fg % 1 # % bring job number into the foreground
    #+end_src
    #+begin_src sh
      stty tostop # disable ability of background to output to controlling terminal
    #+end_src

    generate signals to the foreground process group:
    1. The interrupt character (typically DELETE or Control-C) generates SIGINT.
    2. The quit character (typically Control-backslash) generates SIGQUIT.
    3. The suspend character (typically Control-Z) generates SIGTSTP.

    #+caption: Figure 9.9 Summary of job control features with foreground and background jobs, and terminal driver
    [[file:Chapter09/09fig09.jpg]]

*** DONE 9.9 Shell Execution Programs
    CLOSED: [2019-12-09 Mon 17:42]
    #+begin_src sh :result
      ps -o pid,ppid,pgid,comm
    #+end_src

    #+RESULTS:
    |   PID | PPID |  PGID | COMM                                          |
    |  8101 | 8099 |  8101 | /Applications/iTerm.app/Contents/MacOS/iTerm2 |
    |  8104 | 8102 |  8104 | -zsh                                          |
    |  8727 | 8104 |  8727 | tmux                                          |
    |  8103 | 8099 |  8103 | /Applications/iTerm.app/Contents/MacOS/iTerm2 |
    |  8106 | 8105 |  8106 | -zsh                                          |
    |  8731 | 8725 |  8731 | -zsh                                          |
    | 84043 | 8725 | 84043 | -zsh                                          |
    |  1748 | 8725 |  1748 | -zsh                                          |
    | 17029 | 8725 | 17029 | -zsh                                          |

    #+caption: Figure 9.10 Processes in the pipeline as ~ps | cat1 | cat2 when invoked by bash~
    [[file:Chapter09/09fig10.jpg]]

*** DONE 9.10 Orphaned Process Groups
    CLOSED: [2019-12-13 Fri 23:00]
    #+caption: Figure 9.11 Example of a process group about to be orphaned
    [[file:Chapter09/09fig11.jpg]]

    #+caption: Figure 9.12 Creating an orphaned process group
    #+include: "Chapter09/09fig12.c" src c
    #+begin_quote
    After the fork

    - The parent sleeps for 5 seconds.

    - The child establishes a signal handler for the hang-up signal(SIGHUP) so we can see whether it is sent to the child.

    - The child sends itself to stop signal(SIGTSTP) with the kill function.

    - When the parent terminates, the child is orphaned, so the child's parent process ID becomes 1, which is the init process ID.

    - At this point, the child is now a member of an /orphaned process group/.

    - Since the process group is orphaned when the parent terminates, and the process group contains a stopped process, *POSIX.1 requires that every process in the newly orphaned process group be sent the hang-up signal(SIGHUP) followed by the continue signal(SIGCONT)*

    - This causes the child to be continued, after processing the hang-up signal.

    #+end_quote

*** DONE 9.11 FreeBSD Implementation
    CLOSED: [2019-12-14 Sat 17:05]
    #+caption: Figure 9.13 Free BSD implementation of sessions and process groups
    file:Chapter09/09fig13.jpg

    #+begin_quote
    *session structure*
    * ~s_count~: the number of the process groups in the session.
    * ~s_leader~: a pointer to the proc structure of the session leader
    * ~s_ttyvp~: a pointer to the vnode structure of the controlling terminal
    * ~s_ttyp~: a pointer to the tty structure of the controlling terminal
    * ~s_sid~: the session ID.

    *tty structure*
    * ~t_session~: points to the session structure that has this terminal as its controlling terminal.
    * ~t_pgrp~: points to the pgrp structure of the foreground process group.
    * ~t_termios~: is a structure containing all the special characters and related information for this terminal.
    * ~t_winsize~: is a winsize structure that contains the current size of the terminal window.

    *pgrp structure*
    * ~pg_id~: the process group ID
    * ~pg_session~: points to the session structure to the session leader
    * ~pg_members~: a pointer to the list of members' proc structures

    *proc structure*
    * ~p_pid~: contains the process ID
    * ~p_pptr~: a pointer to the proc structure of the parent process.
    * ~p_pgrp~: a pointer to the pgrp structure of the process group to which it belongs to
    * ~p_pglist~: a structure containing pointers to the next and previous process in the process group.

    *vnode structure* : allocated when the controlling terminal device is opened.
    #+end_quote

*** DONE 9.12 Summary
    CLOSED: [2019-12-14 Sat 17:54]

    - Exercises

      - 9.1

        #+begin_quote
        The init process learns when a terminal user logs out, because init is the parent of the login shell and receives the SIGCHLD signal when the login shell terminates.

        For a network login, however, init is not involved. Instead, the login entries in the utmp and wtmp files, and their corresponding logout entries, are usually written by the process that handles the login and detects the logout (telnetd in our example).
        #+end_quote

      - 9.2

        #+include: "Chapter09/09ex02.c" src c

** DONE Chapter 10. Signals [23/23]
   CLOSED: [2019-11-08 Fri 00:38]

*** DONE 10.1 Introduction
    #+begin_quote
    Signals provide a way of handling asynchronous events
    #+end_quote

*** DONE 10.2 Signal Concepts
    ~<signal.h>~
    conditions can generate a signal
    * terminal generated when users press certain terminal keys.
    * hardware exceptions
    * function ~kill~ (man 2 kill)
    * command ~kill~ (man 1 kill)
    * software conditions : ~SIGURG~ ~SIGPIPE~ ~SIGALARM~

    deal with signals via one of things below:
    * ignore
    * catch
    * use defaut action apply

    #+caption: Figure 10.1 UNIX System signals
    | Name       | Description                                          | Default Action              |
    |------------+------------------------------------------------------+-----------------------------|
    | SIGABRT    | abnormal termination(abort)                          | terminate+core              |
    | SIGALARM   | timer expired(alarm)                                 | terminate                   |
    | SIGBUS     | hardware fault                                       | terminate+core              |
    | SIGCHLD    | change in the status of child                        | ignore                      |
    | SIGCONT    | continue stopped process                             | continue/ignore             |
    | SIGEMT     | hardware fault                                       | terminate+core              |
    | SIGFPE     | arithmetic exception                                 | terminate+core              |
    | SIGFREEZE  | checkpoint freeze                                    | ignore                      |
    | SIGHUP     | hangup                                               | terminate                   |
    | SIGILL     | illegal instruction                                  | terminate+core              |
    | SIGINFO    | status request from keyboard                         | ignore                      |
    | SIGINT     | terminal interrupt character                         | terminate                   |
    | SIGIO      | asynchronous I/O                                     | terminate/ignore            |
    | SIGIOT     | hardware fault                                       | terminate+core              |
    | SIGKILL    | termination : *can't be caught or ignored*           | terminate                   |
    | SIGPIPE    | write to pipe with no readers                        | terminate                   |
    | SIGPOLL    | pollable event(poll): *might be removed*             | terminate                   |
    | SIGPROF    | profiling time alarm(setitimer):  *might be removed* | terminate                   |
    | SIGPWR     | power fail/restart                                   | terminate/ignore            |
    | SIGQUIT    | terminal quit character                              | terminate+core              |
    | SIGSEGV    | invalid memory reference                             | terminate+core              |
    | SIGSTKFLT  | coprocessor stack fault                              | terminate                   |
    | SIGSTOP    | stop: *can't be caught or ignored*                   | stop process                |
    | SIGSYS     | invalid system call                                  | terminate+core              |
    | SIGTERM    | termination                                          | terminate                   |
    | SIGTHAW    | checkpoint thaw                                      | ignore                      |
    | SIGTHR     | threads library internal use                         | terminate                   |
    | SIGTRAP    | hardware fault                                       | terminate+core              |
    | SIGTSTP    | terminal stop character                              | stop process                |
    | SIGTTIN    | background read from control tty                     | stop process                |
    | SIGTTOU    | background write to control tty                      | stop process                |
    | SIGURG     | urgent condition(sockets)                            | ignore                      |
    | SIGUSR1    | user-defined signal                                  | terminate                   |
    | SIGUSR2    | user-defined signal                                  | terminate                   |
    | SIGVTALRM  | virtual time alarm(setitimer)                        | terminate                   |
    | SIGWAITING | threads library internal use                         | ignore                      |
    | SIGWINCH   | terminal window size change                          | ignore                      |
    | SIGXCPU    | CPU limit exceeded (setrlimit)                       | terminate or terminate+core |
    | SIGXFSZ    | file size limit exceeded(setrlimit0)                 | terminate or terminate+core |
    | SIGXRES    | resource control exceeded                            | ignore                      |

    #+begin_quote
    The core file will not be generated if
    1. the process was set-user-ID and the current user is not the owner of the program file
    2. the process was set-group-ID and the current user is not the group owner of the file
    3. the user does not have permission to write in the current working directory
    4. the file already exists and the user does not have permission to write it
    5. the file is too big (recall the RLIMIT_CORE)

    The permission of the core file are usually ~rw~, although Mac OSX sets only ~r~
    #+end_quote

*** DONE 10.3 ~signal~ Function
    #+begin_src sh
      man signal
    #+end_src

    - Example:

    #+caption: Figure 10.2 Simple program to catch SIGUSR1 and SIGUSR2
    #+include: "Chapter10/10fig02.c" src c
    #+begin_quote
    FreeBSD 8.0 and Mac OS X 10.6.8 don’t exhibit this problem, because BSD - based systems generally don’t support historical System V semantics for SIGCLD. Linux 3.2.0 also doesn’t exhibit this problem, because it doesn’t call the SIGCHLD signal handler when a process arranges to catch SIGCHLD and child processes are ready to be waited for, even though SIGCLD and SIGCHLD are defined to be the same value.
    #+end_quote

    - Program Start-Up

      we are not able to determine the current disposition of a signal without changing the disposition

*** DONE 10.4 Unreliable Signals
    In ealier versions of the UNIX system :

    - signals could get lost

    - the process was unable to turn a signal off when it didn’t want the signal to occur

*** DONE 10.5 Interrupted System Calls
    - automatically restarted functions: ~ioctl~, ~read~, ~readv~, ~write~, ~writev~, ~wait~, ~waitpid~

      POSIX.1 requires an implementation to restart system calls only when the SA_RESTART flag is in effect for the interrupting signal.

*** DONE 10.6 Reentrant Functions
    #+caption: Figure 10.5 Call a nonreentrant function from a signal handler
    #+include: "Chapter10/10fig05.c" src c

*** DONE 10.7 ~SIGCLD~ Semantics
    #+caption: Figure 10.6 System V SIGCLD handler that doesn't work
    #+include: "Chapter10/10fig06.c" src c

*** DONE 10.8 Reliable-Signal Terminology and Semantics
    #+begin_quote
    If the system delivers the signal more than once, we say that the signals are queued. \\
    *Most UNIX systems do /not/ queue signals unless they support the real-time extensions to POSIX.1.* \\
    POSIX.1 *does not specify the order* in which the signals are delivered to the process more than once.
    #+end_quote

    * /signal mask/: a set of signals currently blocked from delivery to the process (*on* is blocked)
    * /~sigprocmask~/: examine and change its current signal mask

*** DONE 10.9 ~kill~ and ~raise~ Functions
    #+begin_src c
      #include <signal.h>
      int kill(pid_t pid, int signo);
      int raise(int signo);

      // Both return: 0 if OK, -1 on error
    #+end_src

    ~raise(signo);~ is equivalent to ~kill(getpid(), signo);~

*** DONE 10.10 ~alarm~ and ~pause~ Functions
    #+begin_src c
      #include <unistd.h>
      unsigned int alarm(unsigned int seconds);
      // Returns: 0 or number of seconds until previously set alarm
    #+end_src

    #+begin_quote

There is only one of these alarm clocks per process. If, when we call alarm, a previously registered alarm clock for the process has not yet expired, the number of seconds left for that alarm clock is returned as the value of this function.

If a previously registered alarm clock for the process has not yet expired and if the seconds value is 0, the previous alarm clock is canceled.

If we call alarm first and are sent SIGALRM before we can install the signal handler, our process will terminate
    #+end_quote

    suspends the calling process until a signal is caught
    #+begin_src c
      #include <unistd.h>
      int pause(void);
      // Returns: -1 with errno set to EINTR
    #+end_src

    - Example:

      #+caption: Figure 10.7 Simple, incomplete implementation of sleep
      #+include: "Chapter10/10fig07.c" src c
      #+caption: Figure 10.8 Another (imperfect) implementation of sleep
      #+include: "Chapter10/10fig08.c" src c
      #+caption: Figure 10.9 Calling sleep2 from a program that catches other signals
      #+include: "Chapter10/10fig09.c" src c
      #+caption: Figure 10.10 Calling ~read~ with a timeout
      #+include: "Chapter10/10fig10.c" src c
      #+caption: Figure 10.11 Calling ~read~ with a timeout, using longjmp
      #+include: "Chapter10/10fig11.c" src c

*** DONE 10.11 Signal Sets
    #+begin_src c
      #include <signal.h>
      int sigemptyset(sigset_t *set);
      int sigfillset(sigset_t *set);
      int sigaddset(sigset *set, int signo);
      int sigdelset(sigset *set, int signo);
      // All four returns: 0 if OK, -1 on error

      int sigismember(const sigset *set, int signo);
      // Returns: 1 if true, 0 if false, -1 on error
    #+end_src

    Implementation:
    #+begin_src c
      #define sigemptyset(ptr)  (*(ptr) = 0)
      #define sigfillset(ptr)   (*(ptr) = ~(sigset_t)0, 0)
    #+end_src
    ~sigfillset~ returns value after the comma (value: 0)

    #+caption: Figure 10.12 An implementation of ~sigaddset~, ~sigdelset~, and ~sigismember~

    #+include: "Chapter10/10fig12.c" src c

*** DONE 10.12 ~sigprocmask~ Function
    #+begin_src c
      #include <signal.h>

      int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

      // Returns: 0 if OK, -1 on error
    #+end_src

    #+caption: Figure 10.13 Ways to change the current signal mask using sigprocmask
    | how           | Description                                                    |
    |---------------+----------------------------------------------------------------|
    | ~SIG_BLOCK~   | /set/ contains the additional signals that we want to block.   |
    | ~SIG_UNBLOCK~ | /set/ contains the signals that we want to unblock             |
    | ~SIG_SETMASK~ | new signal mask replaced by the signal set pointed to by /set/ |

    - Example:

      #+caption: Figure 10.14 Print the signal mask for the process
      #+include: "Chapter10/10fig14.c" src c

*** DONE 10.13 ~sigpending~ Function
    #+begin_src c
      #include <signal.h>
      int sigpending(sigset_t *set);
      // Returns: 0 if OK, -1 on error
    #+end_src

    - Example:

      #+caption: Example of signal sets and sigprocmask
      #+include: "Chapter10/10fig05.c" src c

*** DONE 10.14 ~sigaction~ Function
    #+begin_src c
      #include <signal.h>
      int sigaction (int signo, const struct sigaction* restrict act, struct sigaction* restrict oact);
      // Returns: 0 if OK, -1 on error
    #+end_src

    #+begin_src c
      struct sigaction {
              void (*sa_handler) (int);       // addr of signal handler or SIG_IGN or SIG_DFL

              sigset_t sa_mask;               // addtional signals to block
              int sa_flags;                   // signal options, Figure 10.16

              // alternate handler
              void (*sa_action)(int, siginfo_t *, void*);
      };
    #+end_src

    #+caption: Figure 10.16 Option flags (sa_flags) for the handling of each signal
    | Option       | SUS | FreeBSD | Linux | Mac OSX | Solaris | Description                                                                                   |
    |--------------+-----+---------+-------+---------+---------+-----------------------------------------------------------------------------------------------|
    | SA_INTERRUPT | *   |         | *     |         |         | system call interrupted by this signal are not automatically restarted                        |
    | SA_NOCLDSTOP | *   | *       | *     | *       | *       | SIGCHLD do not generate signal when a child process stops(job control).                       |
    | SA_NOCLDWAIT | *   | *       | *     | *       | *       | SIGCHLD prevents the system call from creating process zombie processes                       |
    |              |     |         |       |         |         | when children of the calling process terminate.                                               |
    |              |     |         |       |         |         | if the subsequently calls wait, the calling process blocks until all                          |
    |              |     |         |       |         |         | its child processes have terminated and then returns -1 when errno set to ECHILD              |
    | SA_NODEFER   | *   | *       | *     | *       | *       | signal is not automatically blocked by the system while the signao-catching function executes |
    | SA_ONSTACK   | XSI | *       | *     | *       | *       | if an alternative stack has been declared with ~signalstack~[fn:1]                            |
    | SA_RESETHAND | *   | *       | *     | *       | *       | the disposition for this signal is reset to SIG_DFL, and the SA_SIGINFO flag is cleared       |
    | SA_RESTART   | *   | *       | *     | *       | *       | system calls interrupted by this signal are automatically restarted                           |
    | SA_SIGINFO   | *   | *       | *     | *       | *       | provides additional information to a signal hander                                            |

    #+begin_src c
      // normal signal handler
      void handler(int signo);

      // if SA_SIGINFO flag is set
      void handler(int signo, siginfo_t *info, void *context);

      struct siginfo {
              int si_signo;          // signal number
              int si_errno;          // if nonzero, errno value from errno.h
              int si_code;           // additional info (depends on signal)
              pid_t si_pid;          // sending process ID
              uid_t si_uid;          // sending process real user ID
              void *si_addr;         // address that caused the fault
              int si_status;         // exit value or signal number
              union sigval si_value; // application-specific value
              // possibly other fields also
      };
      union sigval {int sival_int; void* sival_ptr; };

    #+end_src

    ~man sigaction~ (linux)for details

    - Example - ~signal~ function

      #+caption: Figure 10.18 An implementation of signal using sigaction
      #+include: "Chapter10/10fig18.c" src c

    - Example - ~signal_intr~ function

      #+caption: Figure 10.19 The signal_intr function
      #+include: "Chapter10/10fig19.c" src c

*** DONE 10.15 ~sigsetjmp~ and ~siglongjmp~ Functions
    These two functions should always be used when branching from a signal handler.
    #+begin_src c
      #include <setjmp.h>
      int sigsetjmp(sigjmp_buf env, int savemask);
      // Returns: 0 if called directly, nonzero if returning from a call to siglongjmp
      void siglongjmp(sigjmp_buf env, int val);
    #+end_src

    - Example

      #+caption: Figure 10.20 Example of signal masks, sigsetjmp, and siglongjmp
      #+include: "Chapter10/10fig20.c" src c

      #+begin_quote
      If we change the program in Figure 10.20 so that the calls to sigsetjmp and siglongjmp are replaced with calls to setjmp and longjmp on Linux (or _setjmp and _longjmp on FreeBSD), the final line of output becomes

      ending main: SIGUSR1

      This means that the main function is executing with the SIGUSR1 signal blocked, after the call to setjmp.
      #+end_quote

*** DONE 10.16 ~sigsuspend~ Function
    #+begin_src c
      #include <signal.h>
      int sigsuspend(const sigset_t *sigmask);
      // Returns: −1 with errno set to EINTR
    #+end_src

    - Example

      #+caption: Figure 10.22 Protecting a critical region from a signal
      #+include: "Chapter10/10fig22.c" src c

    - Example

      #+caption: Figure 10.23 Using sigsuspend to wait for a global variable to be set
      #+include: "Chapter10/10fig23.c" src c

    - Example

      #+caption: Figure 10.24 Routines to allow a parent and child to synchronize
      #+include: "Chapter10/10fig24.c" src c

    #+begin_quote
    1. Block SIGINT and SIGALRM.

    2. Test the two global variables to see whether either signal has occurred and, if so, handle the condition.

    3. Call read (or any other system function) and unblock the two signals, as an atomic operation.

    The sigsuspend function helps us only if step 3 is a pause operation.
    #+end_quote

*** DONE 10.17 ~abort~ Function
    #+begin_src c
      #include <stdlib.h>
      void abort(void);
    #+end_src

    #+caption: Figure 10.25 Implementation of POSIX.1 ~abort~
    #+include: "Chapter10/10fig25.c" src c

*** DONE 10.18 ~system~ Function
    #+caption: Figure 10.26 Using ~system~ to invoke the =ed= editor
    #+include: "Chapter10/10fig26.c" src c

    #+caption: Figure 10.27 Foreground and background process groups for Figure 10.26
    [[file:Chapter10/10fig27.jpg]]

    #+caption: Figure 10.28 Correct POSIX.1 implementation of ~system~ function
    #+include: "Chapter10/10fig28.c" src c

*** DONE 10.19 ~sleep~, ~nanaosleep~, and ~clock_nanosleep~ Functions
    #+begin_src c
      #include <unistd.h>
      unsigned int sleep(unsigned int seconds);
      // Returns: 0 or number of unslept seconds
    #+end_src

    #+caption: Figure 10.29 Reliable implementation of ~sleep~
    #+include: "Chapter10/10fig29.c" src c

    #+begin_src c
      #include <time.h>
      int clock_nanosleep(clockid_t clock_id, int flags,
                          const struct timespec* reqtp, struct timespec* remtp);
      // Returns: 0 if slept for requested time or error number on failue
    #+end_src

*** DONE 10.20 ~sigqueue~ Function
    - Specify the SA_SIGINFO flag when we install a signal handler using the sigaction function

    - Provide a signal handler in the sa_sigaction member of the sigaction structure instead of using the usual sa_handler field.

    - Use the sigqueue function to send signals.

      #+begin_src c
        #include <signal.h>

        int sigqueue(pid_t pid, int signo, const union sigval value);
        // Returns: 0 if OK, -1 on error
      #+end_src
      #+caption: Figure 10.30 Behavior of queued signals on various platforms
      | Behavior                                                         | SUS      | FreeBSD8.0 | Linux3.2.0 | Mac OSX | Solaris |
      |------------------------------------------------------------------+----------+------------+------------+---------+---------|
      | supports sigqueue                                                | *        | *          | *          |         | *       |
      | queues other signals besides SIGRTMIN to SIGRTMAX                | optional | *          |            |         | *       |
      | queues signals even if the caller don't use the SA_SIGINFO flags | optional | *          | *          |         |         |

*** DONE 10.21 Job-Control Signals
    job-control signals:
    SIGCHLD   Child process has stopped or terminated
    SIGCONT   Continue process, if stopped.
    SIGSTOP   Stop signal(can't caught or ignored)
    SIGTSTP   Interactive stop signal.
    SIGTTIN   Read from controlling terminately by background process group number
    SIGTTOU   Write to controlling terminal by a background process group member

    #+caption: Figure 10.31 How to handle SIGTSTP
    #+include: "Chapter10/10fig31.c" src c

*** DONE 10.22 Signal Names and Numbers
    map between signal numbers and names.
    #+begin_src  c
      extern char *sys_siglist[];
    #+end_src

    in a portable manner
    #+begin_src c
      #include <signal.h>
      void psignal(int signo, const char *msg);
    #+end_src

    print signal information
    #+begin_src c
      #include <signal.h>
      void psiginfo(const siginfo_t* info, const char *msg);
    #+end_src

    string description of the signal and don't necessarily wnat to write it to standard error
    #+begin_src c
      #include <string.h>
      char *strsignal(int signo);
      // Returns: a pointer to a string describing the signal
    #+end_src

    *Solaris provides*
    #+begin_src c
      #include <signal.h>
      int sig2str(int signo, char *str);
      int str2sig(const char *str, int *signop);
      // Both return: 0 if OK, -1 on error
    #+end_src

*** DONE 10.23 Summary
    - Exercises

      - 10.1

        #+begin_quote
        terminates the first time
        ~pause~ until a signal is received from either the kill(2) function or an interval timer
        #+end_quote

      - 10.2

        #+include: "Chapter10/10ex02.c" src c

      - 10.3

        [[file:Chapter10/10ex03.png][file:~/Documents/Notes/books/system/APUE/Chapter10/10ex03.png]]

      - 10.4

        race condition between first call ~alarm~ and ~setjmp~

      - 10.5

        [[http://www.kohala.com/start/libes.timers.txt][www.kohala.com/start/libes.timers.txt]]

      - 10.6

        #+include: "Chapter10/10ex06.c" src c

      - 10.7

        #+begin_quote
        the termination status of the process would not show that it was terminated by the SIGABRT signal.
        #+end_quote

      - 10.8

        #+begin_quote
        If the signal was sent by a process owned by some other user, the process has to be set-user-ID to either root or to the owner of the receiving process, or the kill attempt won’t work. Therefore, the real user ID provides more information to the receiver of the signal.
        #+end_quote

      - 10.9

        #+include: "Chapter10/10ex09.c" src c

      - 10.10

        #+include: "Chapter10/10ex10.c" src c

      - 10.11

        #+include: "Chapter10/10ex11.c" src c
        SIGXFSZ never caught

      - 10.12

        #+include: "Chapter10/10ex02.c" src c
        finished, alarm appears until fwrite finshied, it seems the kernel is blocking SIGALRM

** DONE Chapter 11. Threads [7/7]
   CLOSED: [2019-11-14 Thu 22:35]

*** DONE 11.1 Introduction
    CLOSED: [2019-11-08 Fri 00:42]

*** DONE 11.2 Thread Concepts
    CLOSED: [2020-08-24 Mon 15:28]
    便利：
    - 通过分配单独的线程处理不同的事件类型来简化处理异步事件的代码
    - 多进程需要复杂的技术共享内存和文件描述符。而线程具有相同的内存地址和文件描述符
    - 可以对一些整体问题进行分区以提高吞吐量
    - 交互式程序可以通过多线程区分用户输入和输出以提高响应时间

*** DONE 11.3 Thread Identification
    CLOSED: [2019-11-08 Fri 09:48]
    每一个线程都有一个线程ID。不同于进程ID在系统中唯一，线程ID只有在所属进程中有意义。
    #+begin_src c
      #include <pthread.h>
      /**
       ,*  @brief compare two thread
       ,*  @param tid1     1st thread ID
       ,*  @param tid2     2nd thread ID
       ,*  @return nonzero if equal, 0 otherwise
       ,*/
      int pthread_equal(pthread_t tid1, pthread_t tid2);
    #+end_src

    obtain its own thread ID :
    #+begin_src c
      #include <pthread.h>
      /**
       ,*  @brief obtain thread's ID
       ,*  @return the thread ID of the calling thread
       ,*/
      pthread_t pthread_self(void);
    #+end_src

*** DONE 11.4 Thread Creation
    CLOSED: [2020-08-24 Mon 15:45]
    #+begin_src c
      #include <pthread.h>
      /**
       ,*  @brief create thread
       ,*  @param tidp       the pointer to store thread ID
       ,*  @param attr       specified attributes
       ,*  @param start_rtn  function for thread calling
       ,*  @param arg        for start_rtn
       ,*  @return 0 if OK, error number on failure
       ,*/
      int pthread_create(pthread_t *restrict tidp,
                         const pthread_attr_t *restrict attr,
                         void *(*start_rtn)(void*),
                         void *restrict arg);
    #+end_src

    #+caption: Figure 11.1 Work queue example
    [[file:Chapter11/11fig01.jpg]]

    - Example
      #+caption: Figure 11.2 Printing thread IDs
      #+include: "Chapter11/11fig02.c" src c

*** DONE 11.5 Thread Termination
    CLOSED: [2020-08-25 Tue 13:20]
    1. 线程可以简单地从启动程序退出，返回值即线程返回码
    2. 线程可以被进程内另一线程终止
    3. 可以调用 ~pthread_exit~
    #+begin_src c
      #include <pthread.h>
      void pthread_exit(void *rval_ptr);
    #+end_src

    #+begin_src c
      #include <pthread.h>
      int pthread_join(pthread_t thread, void **rval_ptr);
    #+end_src
    #+begin_quote
    The calling thread will block until the specified thread calls pthread_exit, returns from its start routine, or is canceled.
    #+end_quote

    #+begin_quote
    *The Linux Programming Language:*
    If the main thread calls pthread_exit() instead of calling exit() or performing a return, then the other threads continue to execute.
    #+end_quote

    - Example
      #+caption: Figure 11.3 Fetching the thread exit status
      #+include: "Chapter11/11fig03.c" src c

    - Example
      #+caption: Figure 11.4 Incorrect use of ~pthread_exit~ argument
      #+include: "Chapter11/11fig04.c" src c
      #+begin_quote
      the contents of the structure (allocated on the stack of thread tid1) have changed by the time the main thread can access the structure
      #+end_quote

    #+begin_src c
      #include <pthread.h>
      /**
       ,* @brief      exit with PTHREAD_CANCELED
       ,*
       ,* @details    call pthread_exit with PTHREAD_CANCLED
       ,*
       ,* @param      tid      thread id
       ,*
       ,* @return     0 if OK, error number on failure
       ,*/
      int pthread_cancel(pthread_t tid);
    #+end_src
    in default circumstances, ~pthread_exit~ with *PTHREAD_CANCELD* \\
    doesn't wait for the thread to terminate; it merely makes the request. \\
    similar to ~atexit~ used by a process \\
    known as /thread cleanup handlers/

    #+begin_src c
      #include <pthread.h>
      /**
       ,*  @brief schedules the cleanup function
       ,*
       ,*  - Make a call to pthread_exit
       ,*  - Responds to a cancellation request
       ,*  - Makes a call to pthread_cleanup_pop with a nonzero execute argument
       ,*
       ,*  @param        rtn cleanup handler
       ,*  @param        arg for rtn
       ,*
       ,*/
      void pthread_cleanup_push(void (*rtn)(void*), void *arg);
      /**
       ,*  @brief remove cleanup handler
       ,*
       ,*  @param execute    execute the function if nonzero
       ,*/
      void pthread_cleanup_pop(int execute);
    #+end_src

    - Example
      #+caption: Figure 11.5 Thread cleanup handler
      #+include: "Chapter11/11fig05.c" src c
      #+begin_quote
      当线程通过例程返回被终止时，不调用清理程序

      ~return~ 在FreeBSD Mac OSX 上运行时会断错误并产生 core 文件，这是因为在这些平台上 pthread_cleanup_push 是一个宏并在栈上存储了一些文本，在调用return函数时栈区被覆盖，但调用cleanup时尝试使用此上下文（已损坏）。
      #+end_quote

    #+caption: Figure 11.6 Comparison of process and thread primitives
    | Process primitives | Thread Primitive     | Description                                                 |
    |--------------------+----------------------+-------------------------------------------------------------|
    | fork               | pthread_create       | create a new flow of control                                |
    | exit               | pthread_exit         | exit from an existing flow of control                       |
    | waitpid            | pthread_join         | get exit status from flow of control                        |
    | atexit             | pthread_cleanup_push | register function to be called at exit from flow of control |
    | getpid             | pthread_self         | get ID for flow of control                                  |
    | abort              | pthread_cancel       | request abnormal termination of flow of control             |

    #+begin_quote
    默认情况下，线程终止状态将被保留至调用 ~pthread_join~ ，线程被分离后不可使用 ~pthread_join~ 等待。
    #+end_quote
    #+begin_src c
      #include <pthread.h>
      /**
       ,* @brief      detach a thread
       ,*
       ,* @param      tid      thread id
       ,*
       ,* @return     0 if OK, error number on failure
       ,*/
      int pthread_detach(pthread_t tid);
    #+end_src

*** DONE 11.6 Thread Synchronization [8/8]
    CLOSED: [2020-08-25 Tue 16:16]

    需要线程同步以确保在访问变量内存时不会使用非法值。

    #+caption: Figure 11.7 Interleaved memory cycles with two threads
    [[file:Chapter11/11fig07.jpg]]

    #+caption: Figure 11.8 Two threads synchronizing memory access
    [[file:Chapter11/11fig08.jpg]]

    Increment operation:
    #+begin_quote
    1. Read the memory location into a register.
    2. Increment the value in the register.
    3. Write the new value back to the memory location.

    *If our data always appears to be sequentially consistent, then we need no additional synchronization.*
    #+end_quote

    #+caption: Figure 11.9 Two unsynchronized threads incrementing the same variable
    [[file:Chapter11/11fig09.jpg]]

**** DONE 11.6.1 Mutexes
     CLOSED: [2019-11-08 Fri 15:43]
     #+begin_src c
       #include <pthread.h>
       /**
        ,* @brief      init pthread mutex
        ,*
        ,* @details    detailed description
        ,*
        ,* @param      mutex        mutex to be used
        ,* @param      attr         set attr for mutex
        ,*
        ,* @return     0 if OK, error number on failure
        ,*/
       int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                              const pthread_mutexattr_t *restrict attr);
       /**
        ,* @brief      destroy pthread_mutex
        ,*
        ,* @details    detailed description
        ,*
        ,* @param      mutex        mutex to be destroyed
        ,*
        ,* @return     0 if OK, error number on failure
        ,*/
       int pthread_mutex_destroy(pthread_mutex_t *mutex);
     #+end_src

     #+begin_src c
       #include <pthread.h>
       int pthread_mutex_lock(pthread_mutex_t *mutex);
       int pthread_mutex_trylock(pthread_mutex_t *mutex);
       int pthread_mutex_unlock(pthread_mutex_t *mutex);
       // All return: 0 if OK, error number on failure
     #+end_src

     - Example
       #+caption: Figure 11.10 Using a mutex to protect a data structure
       #+include: "Chapter11/11fig10.c" src c

**** DONE 11.6.2 Deadlock Avoidance
     CLOSED: [2019-11-08 Fri 15:43]
     线程如果尝试两次锁一个互斥锁将会造成 *死锁*

     死锁可以通过谨慎控制锁定 *顺序* 来避免

     - Example
       #+caption: Figure 11.11 Using two mutexes
       #+include: "Chapter11/11fig11.c" src c

     - Example
       #+caption: Figure 11.12 Simplified locking
       #+include: "Chapter11/11fig12.c" src c

**** DONE 11.6.3 ~pthread_mutex_timedlock~ function
     CLOSED: [2019-11-08 Fri 15:53]
     *Mac OSX 10.15.1 doesn't support ~pthread_mutex_timedlock~ yet*

     ~pthread_mutex_timedlock~ is equivalent to ~pthread_mutex_lock~, but returns *ETIMEDOUT* without locking mutex after timeout

     #+begin_src c
       #include <pthread.h>
       #include <time.h>

       int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
                                   const struct timespec *restrict tsptr);

       // Returns: 0 if OK, error number on failure
     #+end_src

     - Example
       #+caption: Figure 11.13 Using ~pthread_mutex_timedlock~
       #+include: "Chapter11/11fig13.c" src c

**** DONE 11.6.4 Reader-Writer Locks
     CLOSED: [2019-11-09 Sat 22:07]
     * mutex  : can only one thread lock it at a time, lock/unlock.
     * rw-lock: read lock, write lock, unlock.
     * rw-lock: 同时间段内只有一个线程可以加写锁，但多个线程允许加读锁
       * w-lock: 所有线程尝试上锁时都会被阻塞直至解锁
       * r-lock: 所有线程尝试读锁时将被允许，但写锁将被阻塞直至释放读锁

     #+begin_src c
       #include <pthread.h>
       int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                               const pthread_rwlockattr_t *restrict attr);
       int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
       // Both return: 0 if OK, error number on failure
     #+end_src
     The Single UNIX specification defines *PTHREAD_RWLOCK_INITIALIZE* constant in the XSI option to initialize a statically allocated rw lock.

     rw-lock control:
     #+begin_src c
       #include <pthread.h>
       int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
       int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
       int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
       // All return: 0 if OK, error number on failure
     #+end_src

     rw-lock try control:
     #+begin_src c
       #include <pthread.h>
       int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
       int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
       // Both return: 0 if OK, error number on failure
     #+end_src

     - Example
       #+caption: Figure 11.14 Using reader-writer locks
       #+include: "Chapter11/11fig14.c" src c

**** DONE 11.6.5 Reader-Writer Locking with Timeouts
     CLOSED: [2019-11-09 Sat 22:25]
     rw-lock with timeout to avoid blocking indefinitely
     #+begin_src c
       #include <pthread.h>
       #include <time.h>

       int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
                                      const struct timespec *restrict tsptr);
       int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
                                      const struct timespec *restrict tsptr);
       // Both return: 0 if OK, error number on failure
     #+end_src
     *the timeout specifies an absolute time, not a relative one.*

**** DONE 11.6.6 Condition Variables
     CLOSED: [2019-11-10 Sun 15:07]
     #+begin_quote
     条件本身被互斥锁保护。一个线程必须锁定互斥锁才能改变条件状态。其它线程只有获取互斥锁时才会提示修改，因为互斥锁必须被锁定才能评估条件。

     assign the constant =PTHREAD_COND_INITIALIZER= to a statically allocated condition variable
     #+end_quote

     ~pthread_cond_init/destroy~
     #+begin_src c
       #include <pthread.h>
       int pthread_cond_init(pthread_cond_t *restrict cond,
                             const pthread_condattr_t *restrict attr);
       int pthread_cond_destroy(pthread_cond_t *cond);
       // Both returns: 0 if OK, error number on failure
     #+end_src

     ~pthread_cond wait/timedwait~
     #+begin_src c
       #include <pthread.h>
       int pthread_cond_wait(pthread_cond_t *restrict cond,
                             pthread_mutex_t *restrict mutex);
       int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                                  pthread_mutex_t *restrict mutex,
                                  const struct timespec *restrict tsptr);
       // Both return: 0 if OK, error number on failure
     #+end_src
     wait as an absolute time instead of a relative time.

     To obtain the absolute time for the timeout value,
     #+begin_src c
       #include <sys/time.h>
       #include <stdlib.h>

       void maketimeout(struct timespec *tsp, long minutes) {
               struct timeval now;

               // get the current time
               gettimeofday(&now, NULL);
               tsp->tv_sec = now.tv_sec;
               tsp->tv_nsec = now.tv_usec * 1000; // usec to nsec
               tsp->tv_sec += minutes * 60;
       }
     #+end_src

     notify threads that a condition has been satisfied.
     #+begin_src c
       #include <pthread.h>
       int pthread_cond_signal(pthread_cond_t *cond);
       int pthread_cond_broadcast (pthread_cond_t *cond);
       // Both return: 0 if OK, error number on failure
     #+end_src

     - Example

       #+caption: Figure 11.15 Using a condition variable
       #+include: "Chapter11/11fig15.c" src c

**** DONE 11.6.7 Spin Locks
     CLOSED: [2019-11-10 Sun 16:15]
     #+begin_quote
     A spin lock is like a mutex, except that *instead of blocking* a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired

     use for short periods of times
     #+end_quote
     #+begin_quote
     Spin locks are useful when used in a nonpreemptive kernel,

     But at user level, spin locks are not as useful unless you are running in a real-time scheduling class that doesn’t allow preemption. User-level threads running in a
     time-sharing scheduling class can be descheduled when their time quantum expires or
     when a thread with a higher scheduling priority becomes runnable. In these cases, if a
     thread is holding a spin lock, it will be put to sleep and other threads blocked on the
     lock will continue spinning longer than intended.
     #+end_quote


     #+begin_src c
       #include <pthread.h>
       int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
       int pthread_spin_destroy(pthread_spinlock_t *lock);
       // Both return: 0 if OK, error number on failure
     #+end_src
     * *PTHREAD_PROCESS_SHARED*: the spin lock can be acquired by threads that have access to the lock's underlying memory
     * *PTHREAD_PROCESS_PRIVATE*: the spin lock can be accessed by only from threads within the process that initialized it.

     ~pthread_spin_trylock~ doesn't spin,
     #+begin_src c
       #include <pthread.h>
       int pthread_spin_lock(pthread_spinlock_t *lock);
       int pthread_spin_trylock(pthread_spinlock_t *lock);
       int pthread_spin_unlock(pthread_spinlock_t *lock);
       // All return: 0 if OK, error number on failure
     #+end_src
     If either pthread_spin_lock or pthread_spin_trylock returns 0, then the spin lock is locked

**** DONE 11.6.8 Barriers
     CLOSED: [2019-11-14 Thu 20:57]
     *Mac OSX doesn't implemented yet, but we can implemente it by pthread_cond and pthread_mutex*
     coordinate multiple threads working in parallel.
     #+begin_src c
       #include <pthread.h>
       int pthread_barrier_init(pthread_barrier_t *restrict barrier,
                                const pthread_barrierattr_t *restrict attr,
                                unsigned int count);
       int pthread_barrier_destroy(pthread_barrier_t *barrier);
       // Both return: 0 if OK, error number on failure
     #+end_src
     *count* refers to the number of threads that must call ~pthread_barrier_wait()~ (includes the calling in process)

     ~pthread_barrier_wait~ indicates a thread is done with its work and is ready to wait for all the other threads to catch up .
     #+begin_src c
       #include <pthread.h>
       int pthread_barrier_wait(pthread_barrier_t *barrier);
       // Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure
     #+end_src
     calling ~pthread_barrier_wait~ is put to sleep if barrier count is not yet satisfied.

     - Example

       #+caption: Figure 11.16 Using a barrier
       #+include: "Chapter11/11fig16.c" src c

*** DONE 11.7 Summary
    CLOSED: [2019-11-15 Fri 00:29]

    - Exercises

      - 11.1

        #+include: "Chapter11/11ex01.c" src c

      - 11.2

        #+begin_quote
        write-mode lock on the whole list while the ID is changing.

        the thread ID between ~job_find~ and ~job_remove~ maybe changed

        to solve this problem, add another mutex in struct job
        #+end_quote

      - 11.3

        #+include: "Chapter11/11ex03.c" src c
        1. rwlock change to condition lock, and need additional mutex lock
        2. data structure for each thread OR
        3. if lock the whole list, the other jobs have to wait, it is the waste of time

      - 11.4

        #+begin_quote
        It depends on the circumstances. In general, both can be correct, but each alternative has drawbacks. In the first sequence, the waiting threads will be scheduled to run after we call pthread_cond_broadcast. If the program is running on a multiprocessor, some threads will run and immediately block because we are still holding the mutex (recall that pthread_cond_wait returns with the mutex held). In the second sequence, a running thread can acquire the mutex between steps 3 and 4, invalidate the condition, and release the mutex. Then, when we call pthread_cond_broadcast, the condition will no longer be true, and the threads will run needlessly. This is why the awakened threads must recheck the condition and not assume that it is true merely because pthread_cond_wait returned.
        #+end_quote

      - 11.5

        pthread_cond && counter
        #+include: "Chapter11/11ex05.c" src c

** DONE Chapter 12. Thread Control [11/11]
   CLOSED: [2019-11-28 Thu 15:37]

*** DONE 12.1 Introduction
    CLOSED: [2019-11-14 Thu 22:39]

*** DONE 12.2 Thread Limits
    CLOSED: [2019-11-15 Fri 08:42]
    #+caption: Figure 12.1 Thread limits and /name/ arguments to ~sysconf~
    | Name of limit                 | Description                                   | /name/ argument                  |
    |-------------------------------+-----------------------------------------------+----------------------------------|
    | PTHREAD_DESTRUCTOR_ITERATIONS | maximum number of times an implemetation will | _SC_THREAD_DESTRUCTOR_ITERATIONS |
    |                               | try to destroy the thread-specific data       |                                  |
    |                               | when a thread exits (Section 12.6)            |                                  |
    | PTHREAD_KEYS_MAX              | maximum number of keys that can be created    | _SC_THREAD_KEYS_MAX              |
    |                               | by a process (Section 12.6)                   |                                  |
    | PTHREAD_STACK_MIN             | minimum number of bytes that can be used      | _SC_THREAD_STACK_MIN             |
    |                               | for a thread's stack (Section by 12.3)        |                                  |
    | PTHREAD_STACK_MAX             | maximum number of threads that can be created | _SC_THREAD_STACK_MAX             |
    |                               | in a process (Section 12.3)                   |                                  |

*** DONE 12.3 Thread Attributes
    CLOSED: [2019-11-15 Fri 16:45]
    #+begin_quote
    1. Each object is associated with its own type of attribute object (threads with thread attributes, mutexes with mutex attributes, and so on).

    2. An initialization function exists to set the attributes to their default values.

    3. Another function exists to destroy the attributes object.

    4. Each attribute has a function to get the value of the attribute from the attribute object.

    5. Each attribute has a function to set the value of the attribute.
    #+end_quote

    #+begin_src c
      #include <pthread.h>
      int pthread_attr_init(pthread_attr_t *attr);
      int pthread_attr_destroy(pthread_attr_t *attr);
      // Both return: 0 if OK, error number on failure
    #+end_src

    attributes:
    #+caption: Figure 12.3 POSIX.1 thread attributes
    | Name          | Description                                       |
    |---------------+---------------------------------------------------|
    | /detachstate/ | detached threada attribute                        |
    | /guardsize/   | guard buffer size in bytes at end of thread stack |
    | /stackaddr/   | lowest address of thread stack                    |
    | /stacksize/   | minimum size in bytes of thread stack             |

    detachstate:
    #+begin_src c
      #include <pthread.h>
      int pthread_attr_getdetachstate(const ptrhead_attr_t *restrict attr,
                                      int *detachstate);
      int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
      // Both return: 0 if OK, error number on failure
    #+end_src
    ~PTHREAD_CREATE_DETACHED~ or ~PTHREAD_CREATE_JOINABLE~

    - Example

      #+caption: Figure 12.4 Creating a thread in the detached state
      #+include: "Chapter12/12fig04.c" src c

    stack:
    #+begin_src c
      #include <pthread.h>
      int pthread_attr_getstack(const pthread_attr_t *restrict attr,
                                void **restrict stackattr,
                                size_t *restrict stacksize);
      int pthread_attr_setstack(pthread_attr_t *attr,
                                void *stackaddr, size_t stacksize);
      // Both return: 0 if OK, error number on failure
    #+end_src

    guardsize:
    #+begin_src c
      #include <pthread.h>
      int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
                                    size_t *restrict guardsize);
      int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
      // Both return: 0 if OK, error number on failure
    #+end_src

    #+begin_quote
    Threads have other attributes not represented by the pthread_attr_t structure: the cancelability state and the cancelability type.
    #+end_quote

*** DONE 12.4 Synchronization Attributes [4/4]
    CLOSED: [2019-11-17 Sun 16:21]

**** DONE 12.4.1 Mutex Attributes
     CLOSED: [2019-11-15 Fri 18:07]
     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_init(pthread_mutexattr_t *attr);
       int pthread_mutexattr_destroy(pthread_mutexattr *attr);
       // Both return: 0 if OK, error number on failure
     #+end_src

     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr,
                                        int *restrict pshared);
       int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
                                        int pshared);
       // Both return: 0 if OK, error number on failure
     #+end_src
     default: ~PTHREAD_PROCESS_PRIVATE~
     #+begin_quote
     multiple threads can access the same synchronization object
     #+end_quote
     other: ~PTHREAD_PROCESS_SHARED~
     #+begin_quote
     a mutex allocated from a memory extent shared between multiple processes may be used for synchronization by those processes.
     #+end_quote

     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict attr,
                                       int *restrict robust);
       int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr, int robust);
       // Both return: 0 if OK, error number on failure
     #+end_src
     default: ~PTHREAD_MUTEX_STALLED~
     #+begin_quote
     use of the mutex can result in undefined behavior, and applications waiting for it to be unlocked are effectively "stalled".
     #+end_quote
     other:   ~PTHREAD_MUTEX_ROBUST~
     #+begin_quote
     This value will cause a thread blocked in a call to pthread_mutex_lock to acquire the lock when another process holding the lock terminates without first unlocking it, but the return value from pthread_mutex_lock is EOWNERDEAD instead of 0.
     #+end_quote

     *Using robust mutexes has to check for three return values instead of two*:
     * success with no recovery
     * success but recovery needj
     * failure

     for application can't be recovered to indicate that the state associated with the mutex is consistent before unlocking the mutex.
     #+begin_src c
       #include <pthread.h>
       int pthread_mutex_consistent(pthread_mutex_t *mutex);
       // Returns: 0 if OK, error number on failure
     #+end_src
     #+caption: mutex types
     | type                     | description                                                          |
     |--------------------------+----------------------------------------------------------------------|
     | PTHREAD_MUTEX_NORMAL     | doesn't do any special error checking or deadlock detection          |
     | PTHREAD_MUTEX_ERRORCHECK | provides error checking                                              |
     | PTHREAD_MUTEX_RECURSIVE  | allow the same thread to lock multiple times without first unlocking |
     | PTHREAD_MUTEX_DEFAULT    | prividing default characteristics and behavior.                      |

     #+caption: Figure 12.5 Mutex type behavior
     | Mutex type               | Relock without unlock? | Unlock when not owned? | Unlock when unlocked? |
     |--------------------------+------------------------+------------------------+-----------------------|
     | PTHREAD_MUTEX_NORMAL     | deadlock               | undefined              | undefined             |
     | PTHREAD_MUTEX_ERRORCHECK | returns error          | returns error          | returns error         |
     | PTHREAD_MUTEX_RECURSIVE  | allowed                | returns error          | returns error         |
     | PTHREAD_MUTEX_DEFAULT    | undefined              | undefined              | undefined             |

     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
                                     int *restrict type);
       int pthread_mutexattr_settype(pthread_mutexattr_t *restrict attr, int type);
       // Both return: 0 if OK, error number on failure
     #+end_src

     #+begin_quote
     If a recursive mutex is locked multiple times and used in a call to pthread_cond_wait, the condition can never be satisfied, because the unlock done by pthread_cond_wait doesn’t release the mutex.

     should be used only when no other solution is possible.
     #+end_quote

     - Example

       #+caption: Figure 12.8 Using a recursive mutex
       #+include: "Chapter12/12fig08.c" src c

**** DONE 12.4.2 Reader-Writer Lock Attributes
     CLOSED: [2019-11-17 Sun 15:55]
     #+begin_src c
       #include <pthread.h>
       int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
       int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);

       int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr,
                                         int *restirct pshared);
       int pthread_rwlockattr_setpshared(const pthread_rwlockattr_t *restrict attr,
                                         int pshared);
       // Both return: 0 if OK, error number on failure
     #+end_src

**** DONE 12.4.3 Condition Variable Attributes
     CLOSED: [2019-11-17 Sun 16:15]
     #+begin_src c
       #include <pthread.h>
       int pthread_condattr_init(pthread_condattr_t *attr);
       int pthread_condattr_destroy(pthread_condattr_t *attr);

       int pthread_condattr_getpshared(pthread_condattr_t const *restrict attr,
                                       int *restrict pshared);
       int pthread_condattr_setpshared(pthread_condattr_t *attr,
                                       int pshared); ;

       int pthread_condattr_getclock(const pthread_condattr_t *restrict attr,
                                     clockid_t *restrict clock_id);
       int pthread_condattr_setclock(pthread_condattr_t *attr,
                                     clockid_t clock_id);
       // Both return: 0 if OK, error number on failure
     #+end_src

**** DONE 12.4.4 Barrier Attributes
     CLOSED: [2019-11-17 Sun 16:21]
     #+begin_src c
       #include <pthread.h>
       int pthread_barrierattr_init(pthread_barrierattr_t *attr);
       int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);

       int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict attr,
                                          int *restrict pshared);
       int pthread_barrierattr_setpshared(const pthread_barrierattr_t *attr,
                                          int pshared);
       // Both return: 0 if OK, error number on failure
     #+end_src

*** DONE 12.5 Reentrancy
    CLOSED: [2019-11-17 Sun 17:13]
    #+begin_quote
    If a function can be safely called by multiple threads at the same time, we say that the function is thread-safe.

    /thread-safe/ version of functions with an _r appended at the end of its name
    #+end_quote

    lock associated with a given FILE object
    #+begin_src c
      #include <sstdio.h>
      int ftrylockfile(FILE *fp);
      // Returns: 0 if OK, nonzero if lock can't be acquired
      void flockfile(FILE *fp);
      void funlockfile(FILE *fp);
    #+end_src
    I/O routines might be implemented to be thread-safe, but locking applications is still useful

    lock associated with character-based standard I/O
    #+begin_src c
      #include <pthread.h>
      int getchar_unlcoked(void);
      int getc_unlcoked(FILE *fp);
      // Both return: the next character if OK, EOF on the end of file or error

      int putchar_unlocked(int c);
      int putc_unlcoked(int c, FILE *fp);
      // Both return: c if OK, EOF on error
    #+end_src
    #+begin_quote
    *These four functions should not be called unless they are surrounded by calls to flockfile (or ftrylockfile) and funlockfile*
    #+end_quote

    - Example

      #+caption: Figure 12.11 A nonreentrant version of getenv
      #+include: "Chapter12/12fig11.c" src c

      #+caption: Figure 12.12 a reentrant (thread-safe) version of getenv
      #+include: "Chapter12/12fig12.c" src c

*** DONE 12.6 Thread-Specific Data
    CLOSED: [2019-11-17 Sun 21:20]
    #+begin_quote
    Thread-specific data, also known as thread-private data, is a mechanism for storing and finding data associated with a particular thread

    The reasons to prevent sharing process data and attributes

    - First, sometimes we need to maintain data on a per-thread basis.

    - The second reason for thread-private data is to provide a mechanism for adapting process-based interfaces to a multithreaded environment.

    #+end_quote

    crate a /key/ to gain acess to with the thread-specific data
    #+begin_src c
      #include <pthread.h>
      int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void*));
      // Returns: 0 if OK, error number on failure
    #+end_src
    break the association of a key with the thread-specific data
    #+begin_src c
      #include <pthread.h>
      int pthread_key_delete(pthread_key_t key);
    #+end_src
    #+begin_quote
    *calling pthread_key_delete will not invoke the destructor function. To free a key:*
    ensure a key we allocated doesn't change because of a race during initialization. Code like the following can result in two threads both calling ~pthread_key_create~:
    #+begin_src c
      void destructor(void *);
      pthread_key_t key;
      int init_done = 0;

      int threadfunc(void *arg) {
              if (!init_done) {
                      init_done = 1;
                      err = pthread_key_create(&key, destructor);
              }
      }
    #+end_src

    The proper way to create a key without a race is as follows:
    #+begin_src c
      void destructor(void *);

      pthread_key_t key;
      pthread_once_t init_done = PTHREAD_ONCE_INIT;

      void thread_init(void) {
              err = pthread_key_create(&key, destructor);
      }

      int threadfunc (void *arg) {
              pthread_once(&init_done, thread_init);
      }
    #+end_src
    #+end_quote

    - Example

      #+caption: Figure 12.13 A thread-safe, compatible version of getenv
      #+include: "Chapter12/12fig13.c" src c

*** DONE 12.7 Cancel Options
    CLOSED: [2019-11-18 Mon 09:49]
    #+begin_quote
    The /cancelability state/ attribute can be either PTHREAD_CANCEL_ENABLE or PTHREAD_CANCEL_DISABLE.
    #+end_quote
    #+begin_src c
      #include <pthread.h>
      int pthread_setcancelstate(int state, int* oldstate);
      // Returns: 0 if OK, error number on failure
    #+end_src

    #+begin_quote
    a call to pthread_cancel doesn’t wait for a thread to terminate. In the default case, a thread will continue to execute after a cancellation request is made until the thread reaches a cancellation point.

    When the state is set to PTHREAD_CANCEL_DISABLE, a call to pthread_cancel will not kill the thread. Instead, the cancellation request remains pending for the thread. When the state is enabled again, the thread will act on any pending cancellation requests at the next cancellation point.
    #+end_quote

    add you own cancellation points
    #+begin_src c
      #include <pthread.h>
      void pthread_testcancel(void);
    #+end_src
    Cancel the pending and enbaled cancellation request, no effect when cancellation is disabled.

    change the cancellation type
    #+begin_src c
      #include <pthread.h>
      int pthread_setcanceltype(int type, int *oldtype);
      // Returns: 0 if OK, error number on failure
    #+end_src
    type: PTHREAD_CANCEL_DEFERRED, PTHREAD_CANCEL_ASYNCHRONOUS

*** DONE 12.8 Threads and Signals
    CLOSED: [2019-11-27 Wed 00:51]
    function like ~sigprocmask~, but works with threads and returns error number instead:
    #+begin_src c
      #include <signal.h>
      int pthread_sigmask(int how, const sigset_t *restrict set,
                          sigset_t *restrict oset);
      // Returns: 0 if OK, error number on failure
    #+end_src
    how values:
    * SIG_BLOCK
    * SIG_SETMASK
    * SIG_UNBLOCK

      wait one or more signals:
    #+begin_src c
      #include <signal.h>
      int sigwait(const siget_t *restrict set, int *restrict signop);
      // Returns: 0 if OK, error number on failure
    #+end_src

    function like ~kill~:
    #+begin_src c
      #include <signal.h>
      int pthread_kill(pthread_t thread, int signo);
      // Returns: 0 if OK, error number on failure
    #+end_src

    - Example:

      #+caption: Figure 12.16 Synchronous signal handling
      #+include: "Chapter12/12fig16.c" src c

*** DONE 12.9 Threads and fork
    CLOSED: [2019-11-28 Thu 01:33]
    #+begin_src c
      #include <pthread.h>
      int pthread_atfork(void (*prepare)(void), void (*parent)(void),
                         void (*child)(void));
      // Returns: 0 if OK, error number on failure
    #+end_src

    * *prepare* called before ~fork~ creates the child process
    * *parent* called in parent after ~fork~ has created the child but before returned
    * *child* called in child before returning

    *the child will get a copy of all locks that the parent defined, but in new memory*
    1. The parent acquired all its locks.
    2. The child acquired all its locks.
    3. The parent released its locks.
    4. The child relased its locks.

    - Example:

      #+caption: Figure 12.17 pthread_atfork example
      #+include: "Chapter12/12fig17.c" src c

    *drawbacks*:
    #+begin_quote
    * no good way to reinitialize the state for more complex synchronization like conditioon and barriers.
    * some implementations of error-checking mutexes will generate errors when the child fork handler tries to unlock a mutex that was locked by the parent
    * recursive mutexes can't be cleand up in the child fork handler, because there is no way to determine the number of times one has been locked
    * if child process are allowed to call only async-singal safe functions, then the child fork handler shouldn't even be able to clean up synchronization objects, because none of the functions are used to manipulate them are async-signal safe.
    * if an application calls fork in a signal handler(which is legal, because fork is async-signal safe), then the fork handlers registered by ~pthread_atfork~ can only async-signal safe functions, or else the results are undefined.
    #+end_quote

*** DONE 12.10 Threads and I/O
    CLOSED: [2019-11-28 Thu 13:31]
    use ~pread/pwrite~ in Chapter 3 to solve I/O at different record

*** DONE 12.11 Summary
    CLOSED: [2019-11-28 Thu 15:37]

    - Exercises

      - 12.1 there are duplicated prints in the file

        #+begin_quote
        This is not a multithreading problem, as one might first guess. The standard I/O routines are indeed thread-safe. When we call fork, each process gets a copy of the standard I/O data structures. When we run the program with standard output attached to a terminal, the output is line buffered, so every time we print a line, the standard I/O library writes it to our terminal. However, if we redirect the standard output to a file, then the standard output is fully buffered. The output is written when the buffer fills or the process closes the stream. When we fork in this example, the buffer contains several printed lines not yet written, so when the parent and the child finally flush their copies of the buffer, the initial duplicate contents are written to the file.
        #+end_quote

      - 12.2 reentrant version of ~putenv~

        #+include: "Chapter12/12ex02.c" src c

      - 12.3 a signal-blocked version of getenv

        #+include: "Chapter12/12ex03.c" src c
        #+begin_quote
        The problem is that we don’t know whether any of the functions we call might unmask a signal that we’ve blocked, thereby making it possible for the function to be reentered through another signal handler.
        #+end_quote

      - 12.4 just copied the answer

        #+begin_quote
        On FreeBSD 8.0, the program drops core. With gdb, we are able to see that the program initialization calls pthread functions, which call getenv to find the value of the LIBPTHREAD_SPINLOOPS and LIBPTHREAD_YIELDLOOPS environment variables. However, our thread-safe version of getenv calls back into the pthread library while it is in an intermediate, inconsistent state. In addition, the thread initialization functions call malloc, which, in turn, call getenv to find the value of the MALLOC_OPTIONS environment variable.

        To get around this problem, we could make the reasonable assumption that program start-up is single threaded, and use a flag to indicate whether the thread initialization had been completed by our version of getenv. While this flag is false, our version of getenv can operate as the non-reentrant version does (and avoid all calls to pthread functions and malloc). Then we could provide a separate initialization function to call pthread_once, instead of calling it from inside getenv. This requires that the program call our initialization function before calling getenv. This solves our problem, because this can’t be done until the program start-up initialization completes. After the program calls our initialization function, our version of getenv operates in a thread-safe manner.
        #+end_quote

      - 12.5 run a program within a program

      - 12.6 implemented sleep by using select

        #+include: "Chapter12/12ex06.c" src c

      - 12.7 unsafe to do that, because we hardly acquire and release the mutex protected condition variable

      - 12.8 use select instead?

        #+include: "Chapter12/12ex08.c" src c

** DONE Chapter 13. Daemon Processes [8/8]
   CLOSED: [2019-12-01 Sun 22:21]

*** DONE 13.1 Introduction
    CLOSED: [2019-11-28 Thu 16:16]
    A process live for a long time in the background.

*** DONE 13.2 Daemon Characteristics
    CLOSED: [2019-11-28 Thu 21:33]
    #+begin_src sh
      ps -axj
    #+end_src

    #+begin_quote
    * The kswapd daemon is also known as pageout daemon. It supports the virtual memory subsystem by writing dirty pages to disk slowly over time, so the pages can be reclamed.
    * The flush daemon fluhes dirty pages to disk when available memory reaches a configured minimum thrshold.
    * The sync_supers daemon periodically fluhes the system metadata to disk.
    * The jbd daemon helps implement the journal in the ext4 file system.
    #+end_quote

    #+begin_quote
    Process 1 is uaually init (launchd on Mac OS X). It is a system daemon responsible for, among other things, starting system services specific to various run levels.

    The rpcbind provides the service of mapping RPC(Remote Procedure Call) program numbers to network port. The rsyslogd daemon is available to any program to log system messages for administrator.

    inetd daemon listens on the system's network interfaces for incoming requests for various network servers. The nfsd, nfsiod, lockd, rpciod, rpc.idmapd, rpc.statd, and rpc.mountd daemons provide support for the Network File System(NFS). The fist four are *kernel* daemons, while the last three are *user-level* daemons

    The cron daemon executes commands at regularly scheduled dates and times.

    most of daemons run with superuser(root) privileges.

    the parent of the user-level daemons is the init process.
    #+end_quote

*** DONE 13.3 Coding Rules
    CLOSED: [2019-11-28 Thu 22:24]
    basic rules to coding a daemon prevent unwanted interactions from happening.
    1. Call unmask to set the file mode createion mask to a known value, usually 0.
    2. Call fork and have the parent exit.
    3. Call setsid to create a new session.
       1. becomes the leader of a new session
       2. becomes the leader of a new process group
       3. is disassociated from its controlling terminal
    4. Change the current working directory to the root directory.
    5. Unneeded file descriptors should be closed
    6. Some daemons open file descriptors 0, 1 and 2 to /dev/null so that any library routines that try to read from standard input or write to standard output or standard error will have no effect.

    - Example

      #+caption: Figure 13.1 initialize a daemon process
      #+include: "Chapter13/13fig01.c" src c

*** DONE 13.4 Error Logging
    CLOSED: [2019-11-29 Fri 01:03]
    three ways to generate log messages:
    * Kernel routines can call the log function.
    * Most user processes (daemons) call the syslog(3) function to generate log messages.
    * A user process on this host, or on some other host that is connected to this host by a TCP/IP network can send log messages to UDP port 514.

    #+begin_src c
      #include <syslog.h>
      void openlog(const char *ident, int option, int facility);
      void syslog(int priority, const char *fmt, ...);
      void closelog(void);

      int setlogmask(int maskpri);
      // Returns: previous log priority mask value
    #+end_src
    calling openlog is optional. the first time syslog called automatically calls openlog.

    calling closelog is also optional.

    #+caption: Figure 13.3 The /option/ argument for ~openlog~
    | /option/   | Description                                                                                        |
    |------------+----------------------------------------------------------------------------------------------------|
    | LOG_CONS   | ifthe log message can't be sent to syslog via the UNIX domain datagram,                            |
    |            | the message is writen to the console instead                                                       |
    | LOG_NDELAY | Open the UNIX domain datagram socket to the syslogd daemon immediately;                            |
    |            | don't wait until the frst message is logged.                                                       |
    |            | Normally, the socket is not opened until the first message is logged.                              |
    | LOG_NOWAIT | Do not wait for child processes that might have been created in the process                        |
    |            | of logging message. The prevents conflicts with applications that catch *SIGCHLD*,                 |
    |            | since the application might have retrieved the child's status by the time that syslog calls ~wait~ |
    | LOG_ODELAY | Delay the opening ofthe connection to the syslogd daemon until the first message is logged.        |
    | LOG_PERROR | write the log message to standard error in addition to sending it to syslogd                       |
    | LOG_PID    | Log the process ID with each message. This is intended fr daemons that fork a child process        |
    |            | to handle different requests (as compared to daemons, such as syslogd, that never call fork)       |

    */format/ and any other arguments are passed to vsprintf function for formatting. %m in /format/ are first replaced with the error message string(strerror)*

    - Example

      #+begin_src c
        openlog("lpd", LOG_PID, LOG_LPR);
        syslog(LOG_ERR, "open error for %s: %m", filename);
      #+end_src
      if we had not called ~openlog~, the second call could have been
      #+begin_src c
        syslog(LOG_ERR | LOG_LPR, "open error for %s: %m", filename);
      #+end_src

    #+caption: Figure 13.4 The /facility/ argument for ~openlog~
    | facility     | XSI | Description                                                     |
    |--------------+-----+-----------------------------------------------------------------|
    | LOG_AUDIT    |     | the audit fcility                                               |
    | LOG_AUTH     |     | authorization programs: login, su, getty, ...                   |
    | LOG_AUTHPRIV |     | same as LOG_AUTH, but logged to fle with restricted permissions |
    | LOG_CONSOLE  |     | messages written to /dev/console                                |
    | LOG_CRON     |     | cron and at                                                     |
    | LOG_DAEMON   |     | system daemons: inetd, routed, ...                              |
    | LOG_FTP      |     | the FTP daemon (ftpd)                                           |
    | LOG_KERN     |     | messages generated by the kernel                                |
    | LOG_LOCAL0   | *   | reserved for local use                                          |
    | LOG_LOCAL1   | *   | reserved for local use                                          |
    | LOG_LOCAL2   | *   | reserved for local use                                          |
    | LOG_LOCAL3   | *   | reserved for local use                                          |
    | LOG_LOCAL4   | *   | reserved for local use                                          |
    | LOG_LOCAL5   | *   | reserved for local use                                          |
    | LOG_LOCAL6   | *   | reserved for local use                                          |
    | LOG_LOCAL7   | *   | reserved for local use                                          |
    | LOG_LPR      |     | line printer system: lpd, lpc, ...                              |
    | LOG_MAIL     |     | the mail system                                                 |
    | LOG_NEWS     |     | the network time protocol system                                |
    | LOG_SECURITY |     | the security subsystem                                          |
    | LOG_SYSLOG   |     | the syslogd daemon itself                                       |
    | LOG_USER     | *   | message from other user processes(deafult)                      |
    | LOG_UUCP     |     | the UUCP system                                                 |

    #+caption: Figure 13.5 The ~syslog~ /levels/ (ordered)
    | level       | Description                                        |
    |-------------+----------------------------------------------------|
    | LOG_EMERG   | emergency (system is unusuable) (highest priority) |
    | LOG_ALERT   | condition that must be fxed immediately            |
    | LOG_CRIT    | critical condition (e.g., hard device error)       |
    | LOG_ERR     | error condition                                    |
    | LOG_WARNING | warning condition                                  |
    | LOG_NOTICE  | normal, but significant condition                  |
    | LOG_INFO    | infrmational message                               |
    | LOG_DEBUG   | debug message(lowest priority)                     |

    syslog that handles variable argument lists
    #+begin_src c
      #include <syslog.h>
      #include <stdarg.h>

      void vsyslog(int priority, const char *format, va_list arg);
    #+end_src

*** DONE 13.5 Single-Instance Daemons
    CLOSED: [2019-11-29 Fri 10:25]

    - Example:

      #+caption: Figure 13.6 Ensure that only one copy of a daemon is running
      #+include: "Chapter13/13fig06.c" src c

*** DONE 13.6 Daemon Conventions
    CLOSED: [2019-12-01 Sun 18:04]

    - daemon's lock file is usually stored in /var/run. (might need superuser permissions to create a file here.)

    - daemon's configuration options usually stored in /etc

    - daemons can be started from the command line , but they are usually started from one of the system initialization scripts

    - daemon read configuration file when it starts, but usually won't look at it again.

    - Example:

      #+caption: Figure 13.7 Daemon reredaing configuration files
      #+include: "Chapter13/13fig07.c" src c

    - Example:

      #+caption: Figure 13.8 Alternative implementation of daemon rereading configuration files
      #+include: "Chapter13/13fig08.c" src c

*** DONE 13.7 Client-Server Model
    CLOSED: [2019-12-01 Sun 18:40]
    #+caption: Figure 13.9 Set close-on-exec flag
    #+include: "Chapter13/13fig09.c" src c

*** DONE 13.8 Summary
    CLOSED: [2019-12-01 Sun 22:20]

    - Exercises

      - 13.1 actually I didn't find there is anything wrong here, but the answer is:

        #+begin_quote
        If it calls chroot, the process will not be able to open /dev/log. The solution is for the daemon to call openlog with an option of LOG_NDELAY, before calling chroot. This opens the special device file (the UNIX domain datagram socket), yielding a descriptor that is still valid, even after a call to chroot. This scenario is encountered in daemons, such as ftpd (the File Transfer Protocol daemon), that specifically call chroot for security reasons but still need to call syslog to log error conditions.
        #+end_quote

      - 13.2 syslog did not to create a session

      - ...

      - 13.4 code below

        #+caption: call daemon and get login name
        #+include: "Chapter13/13ex04.c" src c

** DONE Chapter 14. Advanced I/O [9/9]
   CLOSED: [2019-12-29 Sun 02:15]

*** DONE 14.1 Introduction
    nonblocking I/O, I/O multiplexing(~select~ and ~poll~), asynchronous I/O, the ~readv~ and ~writev~ functions, and memory-mapped I/O (mmap).

*** DONE 14.2 Nonblocking I/O
    CLOSED: [2019-12-15 Sun 02:40]
    slow system calls can block forever. include:
    * reads if data isn't present with certain file types
    * writes if data isn't present with certain file types
    * open conditions
    * mandatory record locking
    * ~ioctl~ options
    * IPC

    Q: What does Nonblocking do?
    A: returns immediately with an error nothing that the operation would have blocked if the operation cannot be completed.

    two way to specify nonblocking I/O:
    1. ~open~ to get the descriptor, specify ~O_NONBLOCK~ flag
    2. call ~fcntl~ to trun on the ~O_NONBLOCK~ if already open.

    - Example

      #+caption: Figure 14.1 Large nonblocking write
      #+include: "Chapter14/14fig01.c" src c
      #+begin_src sh :result
        ls -l /etc/services
        bin/14fig01 < /etc/services > temp.file
        ls -l temp.file
      #+end_src

      #+RESULTS:
      | -rw-r--r-- | 1 | root   | wheel | 677972 | Aug | 25 | 06:20 | /etc/services |
      | -rw-r--r-- | 1 | zhoush | staff |  50000 | Dec | 15 | 02:16 | temp.file     |

      #+begin_src sh :result
        bin/14fig01 < /etc/services 2>stderr.out
        cat stderr.out
      #+end_src

      #+begin_quote
      On OSX, a there are lots of
      nwirte = some number, errno = 0
      nwrite = -1, errno = 35

      but on Linux, the error message is
      nwrite = -1, errno = 11 instead

      *they are both EAGAIN number*
      #+end_quote

*** DONE 14.3 Record Locking
    Record locking is the term normally used to describe the ability of a process to prevent other processes from modifying a region of a file while the first process is reading or modifying that portion of the file

    - 1. History

    #+caption: Figure 14.2 Forms of record locking supported by various UNIX systems
    | Systems         | Advisory | Mandatory | fcntl | lockf | flock |
    |-----------------+----------+-----------+-------+-------+-------|
    | SUS             | *        |           | *     | XSI   |       |
    |-----------------+----------+-----------+-------+-------+-------|
    | FreeBSD 8.0     | *        |           | *     | *     | *     |
    | Linux 3.2.0     | *        | *         | *     | *     | *     |
    | Mac OS X 10.6.8 | *        |           | *     | *     | *     |
    | Solaris         | *        | *         | *     | *     | *     |

    - 2. ~fcntl~ Record Locking

      #+begin_src c
        #include <fcntl.h>
        int fcntl.(int fd, int cmd, ... /* struct flock *flockptr */);
        // Returns: depends on cmd if OK (see following), -1 on error
      #+end_src
      ~cmd~ is F_GETLK, F_SETLK, or F_SETLKW.

      #+begin_src c
        struct flock {
                short l_type;                  // F_RDLCK, or F_UNLCK
                short l_whence;                // SEEK_SET, SEEK_CUR, or SEEK_END
                off_t l_start;                 // offset in bytes, relative to l_whence
                off_t l_len;                   // length, in bytes; 0 means lock to EOF
                pid_t l_pid;                   // returned with F_GETLK
        };
      #+end_src

      - describes

        - The type of lock desired: F_RDLCK, F_WRLCK, or F_UNLCK

        - The starting byte offset of the region being locked or unlocked (l_start and l_whence)

        - The size of the region in bytes(l_len)

        - The ID(l_pid) of the process holding the lock that can block the current process(returned by F_GETLK only)

      - rules to the specification of the region to be locked or unlocked

        - The two elements that specify the starting offset of the region are similar to the last two arguments of the ~lseek~ function.

        - Locks can start and extend beyond the current end of file, but cannot start or extend before the beginning of the file

        - if l_len is 0, it means that the lock extends to the *largest* possible offset of the file

        - To lock the entire file, we set l_start and l_whence to point the beginning of the file and specify a length(l_len) of 0.

        #+caption: Figure 14.3 Compatibility between different types
        | conditions             | read lock | write lock |
        |------------------------+-----------+------------|
        | no locks               | OK        | OK         |
        | one or more read locks | OK        | denied     |
        | one or more write lock | denied    | denied     |

      - Commands for the ~fcntl~ function

        - F_GETLK: determine lock

        - F_SETLK: set lock, also used to clear lock(F_UNLCK)

        - F_SETLWK: a block version of F_SETLK. (The *W* means wait)

    testing for a lock with F_GETLK and then trying to obtain that lock with F_SETLK or F_SETLKW is not an atomic operation

    #+caption: Figure 14.4 File byte-range lock diagram
    [[file:Chapter14/14fig04.jpg]]

    - Example - Requesting and Releasing a Lock

      #+caption: Figure 14.5 Function to lock or unlock a region of a file
      #+include: "Chapter14/14fig05.c" src c

    - Example - Testing for a Lock

      #+caption: Figure 14.6 Function to test for a locking condition
      #+include: "Chapter14/14fig06.c" src c

    - Example - Deadlock

      #+caption: Figure 14.7 Example of deadlock detection
      #+include: "Chapter14/14fig07.c" src c

    - Implied Inheritance and Release of Locks

      1. Locks are associated with a process and a file.
      2. Locks are never inherited by the child accross a fork
      3. Locks are inherited by a new program accross exec.

    - FreeBSD Implementation

      #+caption: Figure 14.8 The FreeBSD data structures for record locking
      [[file:Chapter14/14fig08.jpg]]
      new here are *lockf* structure

      - Example

        #+caption: Figure 14.9 Place a write lock on an entire file
        #+include: "Chapter14/14fig09.c" src c

      macro
      #+begin_src c
        #define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)
      #+end_src

    - Locks at End of File

      #+begin_src c
        // The commented code should be the right one
        writew_lock(fd, 0, SEEK_END, 0);
        write(fd, buf, 1);
        un_lock(fd, 0, SEEK_END);       // un_lock(fd, -1, SEEK_END) instead
        write(fd, buf, 1);
      #+end_src
      #+caption: Figure 14.10 File range lock diagram
      [[file:Chapter14/14fig10.jpg]]

    - Advisory versus Mandatory Locking

      #+caption: Figure 14.11 Effect of mandatory locking on reads and writes by other processes
      [[file:Chapter14/14fig11.jpg]]

      - Example

        #+caption: Figure 14.12 Determine whether mandatory locking is supported
        #+include: "Chapter14/14fig12.c" src c
        #+begin_src sh :result
          bin/14fig12 temp.lockk
        #+end_src

        #+RESULTS:
        | read_lock of already-locked region returns 35 |          |
        | read OK(no mandatory locking)                 | buf = ab |

*** DONE 14.4 I/O Multiplexing [2/2]
    CLOSED: [2020-03-06 Fri 16:21]

    #+begin_src dot :file Chapter14/14fig13.jpg :cmdline -Kdot -Tpng
      digraph G {
      label="Figure 14.13 Overview of telnet program"
      labelloc=top

      rankdir=LR
      node[fontsize=16]
      T [label="user at a\nterminal", shape=oval]
      C [label="telnet\ncommand", shape=rectangle]
      D [label="telnetd\ndaemon", shape=oval]

      T -> C -> D -> C -> T
      }
    #+end_src

    #+RESULTS:
    [[file:Chapter14/14fig13.jpg]]

    #+begin_src dot :file Chapter14/14fig14.jpg :cmdline -Kdot -Tpng
      digraph G {
      label="Figure 14.14 The telnet program using two processes"
      labelloc=top

      node[fontsize=16]
      rankdir=LR

      T[label="user at a\nterminal", shape=oval]
      P[label="telnet command\n(parent)", shape=rectangle]
      C[label="telnet command\n(child)", shape=rectangle]
      D[label="telnetd\ndaemon", shape=oval]

      {rank=same; P C}

      T -> P -> D -> C -> T
      }
    #+end_src

    #+RESULTS:
    [[file:Chapter14/14fig14.jpg]]

    polling:
    * waste CPU time

    asynchronous IO:
    * *we tell the kernel to notify us with a signal when a descriptor is ready for I/O.
    * *If we enable this signal for two descriptors (in the example we’ve been talking about, reading from two descriptors), the occurrence of the signal doesn’t tell us which descriptor is ready.

    I/O multiplexing:
    * build a list of descriptors that we are interested in
    * call a function that doesn't return until one of the descriptors is ready for I/O.

**** DONE 14.4.1 ~select~ and ~pselect~ Functions
     CLOSED: [2019-12-18 Wed 01:01]
     select arguments:
     * which descriptors we're interested in
     * which conditions we're interested in for each descriptor.
     * How long we want to wait.

     return information:
     * The total count of the number of descriptors that are ready.
     * which descriptors are ready for each of the three conditions (read, write, or exception)
     #+begin_src c
       #include <sys/select.h>
       int select(int maxfdp1, fd_set *restrict readfds,
                  fd_set *restrict wriefds, fd_set *restrict exceptfds,
                  struct timevval *restrict tvptr);
       // Returns: count of ready descriptors, 0 on timeout, -1 on error
     #+end_src

     #+name: fd_set relevant
     #+begin_src c
       #include <sys/select.h>
       int FD_ISSET(int fd, fd_set *fdset);
       // Returns: nonzero if fd is in set, 0 otherwise

       void FD_CLR(int fd, fd_set *fdset);
       void FD_SET(int fd, fd_set *fdset);
       void FD_ZERO(fd_set *fdset);
     #+end_src

     #+name: POSIX.1 defines a variant of select
     #+begin_src c
       #include <sys/select.h>
       int pselect(int maxfdp1, fd_set *restrict readfds,
                   fd_set *restrict writefds, fd_set *restrict exceptfds,
                   const struct timespec *restrict tsptr,
                   const sigset_t *restrict sigmask);
     #+end_src
     differences from select
     * timeout value for ~select~ is specified by a timeval structure, but timespec structure for pselect
     * timeout for pselect is declared const
     * An optional signal mask argument is available for pselect.

**** DONE 14.4.2 ~poll~ Function
     CLOSED: [2019-12-18 Wed 17:35]
     ~poll~ is similar to ~select~, but without differentiating conditions
     #+begin_src c
       #include <poll.h>
       int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);
     #+end_src

     #+begin_src c
       typedef struct {
               int   fd;                        // file descriptor to check, or <0 to ignore
               short events;                    // events of interest on fd
               short revents;                   // events that occurred on fd
       };
     #+end_src

     #+caption: Figure 14.17 The events and revents flags for poll
     | Name       | Input to events? | Result from revents? | Description                                     |
     |------------+------------------+----------------------+-------------------------------------------------|
     | POLLIN     | *                | *                    | Equivalent to POLLRDNORM =OR= POLLRDBAND        |
     | POLLRDNORM | *                | *                    | Normal data can bread without blocking          |
     | POLLRDBAND | *                | *                    | Priority data can be read without blocking      |
     | POLLPRI    | *                | *                    | High-priority data can be read without blocking |
     |------------+------------------+----------------------+-------------------------------------------------|
     | POLLOUT    | *                | *                    | Normal data can be written without blocking     |
     | POLLWRNORM | *                | *                    | Same as POLLOUT                                 |
     | POLLWRBAND | *                | *                    | Priority data can be written without blocking   |
     |------------+------------------+----------------------+-------------------------------------------------|
     | POLLERR    |                  | *                    | An error has occurred                           |
     | POLLHUP    |                  | *                    | A hangup has occurred                           |
     | POLLNVAL   |                  | *                    | The descriptor does not reference an open file  |

     When a descriptor is hang up (POLLHUP), we can no longer write, but still can read

     - Interruptibility of ~select~ and ~poll~

       When the automatic restarting of interrupted system calls was introduced with 4.2BSD, the ~select~ function was never restarted.  \\
       even if the SA_RESTART option is specified. \\
       but under SVR4, if SA_RESTART was specified, even ~select~ and ~poll~ were automatically restarted.

*** DONE 14.5 Asynchronous I/O [3/3]
    CLOSED: [2019-12-27 Fri 00:35]

**** DONE 14.5.1 System V Asynchronous I/O
     CLOSED: [2019-12-19 Thu 16:32]
     ~<stropt.h>~
     #+caption: Figure 14.18 Conditions for generating SIGPOLL signal
     | Constant  | Description                                                                 |
     |-----------+-----------------------------------------------------------------------------|
     | S_INPUT   | We can read data (other than high-priority data) without blocking           |
     | S_RDNORM  | We can read normal data without blocking                                    |
     | S_RDBND   | We can read priority dat without blocking                                   |
     | S_BANDURG | If this constant is specified with S_RDBAND, the SIGURG signal is generated |
     |           | instead of SIGPOLL When we can read priority data without blocking          |
     | S_HIPRI   | we can read high-priority data without blocking                             |
     | S_OUTPUT  | We can write normal data wihout blocking                                    |
     | S_WRNORM  | Same as S_OUTPUT                                                            |
     | S_WRBAND  | We can write priority data without blocing.                                 |
     | S_MSG     | The SIGPOLL signal message has reached the stream head.                     |
     | S_ERROR   | The stream has an error.                                                    |
     | S_HANGUP  | The stream has hung up.                                                     |

**** DONE 14.5.2 BSD Asynchronous I/O
     CLOSED: [2019-12-19 Thu 16:50]
     Asynchronous I/O in BSD-derived system is a combination of two signals: SIGIO and SIGURG.

     To receive the =SIGIO= signal, perform the following steps:
     1. Establish a signal handler for SIGIO, by calling either ~signal~ or ~sigaction~.
     2. Set the process ID or process group ID to receive the signal for the descriptor, by calling ~fcntl~ with a command of =F_SETOWN= (Section 3.14)
     3. Enable asynchronous I/O on the descriptor by calling ~fcntl~ with a command of ~F_SETFL~ to set the =O_ASYNC= file status flag (Figure 3.10)

     For the =SIGURG= signal, we need perform only steps 1 and 2. =SIGURG= is generated only for descriptors that refer to network connections that support out-of-band data, such as TCP connections.

**** DONE 14.5.3 POSIX Asynchronous I/O
     CLOSED: [2019-12-27 Fri 00:35]
     The asynchronous I/O interfaces use AIO control blocks to describe I/O operations.
     #+begin_src c
       struct aiocb {
               int             aio_filedes;    // file descriptor
               off_t           aio_offset;     // file offset for I/O
               volatile void   *aio_buf;       // buffer for I/O
               size_t          aio_nbytes;     // number of bytes to transfer
               int             aio_reqprio;    // priority
               struct sigevent aio_sigevent;   // signal information
               int             aio_lio_opcode; // operation for list I/O
       };
     #+end_src

     #+begin_src c
       struct sigevent {
               int             sigev_notify;                // notify type
               int             sigev_signo;                 // signal number
               union sigval    sigev_values;                // notify argument
               void (*sigev_notify_function)(union sigval); // notify function
               pthread_attr_t *sigev_notify_attributes;     // notify attrs
       };
     #+end_src
     =sigev_notify= taks one of three values:
     * SIGEV_NONE    The process is not notified when the asynchronous I/O request completes.
     * SIGEV_SIGNAL  The signal specified by the =sigev_signo= field is generated when the asynchronous I/O request completes.
     * SIGEV_THREAD  The function specified by the =sigev_notify_function= field is called when the asynchronous I/O request completes.

     AIO related functions:
     #+begin_src c
       #include <aio.h>

       int aio_read(struct aiocb *aiocb);
       int aio_write(struct aiocb *aiocb);
       // Both return 0 if OK, -1 on error
       // When the functions return success, the asynchronous I/O request has been queued for processing by the operating system.

       /// @brief force write all pending asynchronous
       int aio_fsync(int op, struct aiocb *aiocb);
       // Returns: 0 if OK, -1 on error

       /// @brief determine the completion status of beyond operations
       int air_error(const struct aiocb* aiocb);
       // Returns: 0             if SUCCESS (need to cal aio_return)
       //         -1            on ERROR (errno for details)
       //         EINPROGRESS   still pending

       /// @brief get return value if succeeded
       ssize_t aio_return(const struct aiocb *aiocb);
       // Returns: return results if OK, -1 and set errno on error

       /// @brief block operation until an operation completes
       int aio_suspend(const struct aiocb *const list[], int ncnt,
                       const struct timespec *timeout);
       // Returns: 0 if OK, -1 on error

       /// @brief cancel pending asynchronous I/O operations
       int aio_cancel(int fd, struct aiocb *aiocb);
       // Returns: AIO_ALLDONE      all of the operations completed before the attempt to cancel
       //          AIO_CANCELED     all of the requested operations have been canceled
       //          AIO_NOTCANCELED  at least one of the requested operations could not be canceled
       //          -1               failed.
     #+end_src

     additional function submits a set of I/O requests described by a list of AIO control blocks
     #+begin_src c
       #include <aio.h>
       int lio_listio(int mode, struct aiocb *restrict const list[restrict],
                      int ncnt, struct sigevent *restrict sigev);
       // Returns: 0 if OK, -1 on error
     #+end_src

     mode: =LIO_WAIT= / =LIO_NOWAIT=
     list: points to a list of AIO control blocks specifying the I/O operations to perform (LIO_READ, LIO_WRITE in =aio_lio_opcode=)
     ncnt: count of list

     #+caption: Figure 14.19 POSIX.1 runtime invariant values for asynchronous I/O
     | Name               | Description                                                                        | Minimum acceptable values |
     |--------------------+------------------------------------------------------------------------------------+---------------------------|
     | AIO_LISTIO_MAX     | maximum number of I/O operations in a single list I/O call                         | _POSIX_AIO_LISTIO_MAX     |
     | AIO_MAX            | maximum number of outstanding asynchronous I/O operations                          | _POSIX_AIO_MAX            |
     | AIO_PRIO_DELTA_MAX | maximum amount by which a process can decrease its asynchronous I/O priority level | 0                         |
     =AIO_LISTIO_MAX=      = sysconf(_SC_IO_LISTIO_MAX)
     =AIO_MAX=             = sysconf(_SC_AIO_MAX)
     =AIO_PRIO_DELTA_MAX=  = sysconf(_SC_AIO_PRIO_DELTA_MAX)

     #+caption: Figure 14.20 Translate a file using ROT-13
     #+include: "Chapter14/14fig20.c" src c

     #+caption: Figure 14.21 Translate a file using ROT-13 and asynchronous I/O
     #+include: "Chapter14/14fig21.c" src c
     #+begin_quote
     this might actually reduce performance—if the reads are presented to the ﬁle system out of order, it can defeat the operating system's read-ahead algorithm.
     #+end_quote

*** DONE 14.6 ~readv~ and ~writev~ Functions
    CLOSED: [2019-12-27 Fri 01:26]
    /scatter read/ and /gather write/.
    #+begin_src c
      #include <sys/uio.h>
      ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
      ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
      // Both return: number of bytes read or written, -1 on error

      struct iovec {
              void   *ivo_base;                 // starting address of buffer
              size_t  iov_len;                  // sizeof of buffer
      };
    #+end_src

    #+caption: Figure 14.22 The iovec structure for readv and writev
    [[file:Chapter14/14fig22.jpg]]

    Three ways to write two buffers consecutively to a file:
    1. Call ~write~ twice, once for each buffer
    2. allocate a buffer, merge two buffers into the allocated buffer, then call ~write~
    3. call ~writev~ to both buffers

    #+caption: Figure 14.23 Timing results comparing writev and other techniques
    [[file:Chapter14/14fig23.jpg]]

*** DONE 14.7 ~readn~ and ~writen~ Functions
    CLOSED: [2019-12-28 Sat 02:52]
    impletations for reading/writing only /n/ bytes
    #+begin_src c
      #include "apue.h"
      ssize_t readn(int fd, void *buf, size_t nbytes);
      ssize_t writen(int fd, void *buf, size_t nbyts);
      // Both Returns: number of bytes read or write, -1 on error
    #+end_src

    #+caption: Figure 14.24 The ~readn~ and ~writen~ functions
    #+include: "Chapter14/14fig24.c" src c

*** DONE 14.8 Memory-Mapped I/O
    CLOSED: [2019-12-28 Sat 15:27]
    map a file on disk into a buffer in memory so that, when we fetch bytes from the buffer, the corresponding bytes of the file are read.
    #+begin_src c
      #include <sys/mman.h>
      /**
       ,* @brief      map a file on disk into a buffer in memory
       ,*
       ,*
       ,* @return     starting address of mapped region if OK, MAP_FAILED on error
       ,*/
      void *mmap(void *addr, size_t len, int prot, int flag, int fd, off_t off);

      /// @brief unmap a memory-mapped region
      /**
       ,* @brief      unmap a memory-mapped region
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int munmap(void *addr, size_t len);
    #+end_src

    #+caption: Figure 14.25 Protection of memory-mapped region
    | prot       | Description               |
    |------------+---------------------------|
    | PROT_READ  | Region can be read        |
    | PROT_WRITE | Region can be written     |
    | PROT_EXEC  | Region can be executed    |
    | PROT_NONE  | Region cannot be accessed |

    #+caption: Figure 14.26 Example of a memory-mapped file
    [[file:Chapter14/14fig26.jpg]]

    /flag/ argument:

    - MAP_FIXED: The return value must equal /addr/.

    - MAP_SHARED: describe the disposition of store operations into the mapped region by this process.

    - MAP_PRIVATE: store operations into the mapped region cause a private copy of the mapped file to be created.

    - MAP_xxx: check ~mmap(2)~ for additional flag values

    - Example

      #+caption: Figure 14.27 Copy a file using memory-mapped I/O
      #+include: "Chapter14/14fig27.c" src c

    #+begin_src c
      #include <sys/mman.h>
      /**
       ,* @brief change the permissions on an existing mmaping
       ,*
       ,* @retval 0     OK
       ,* @retval -1    error
       ,*/
      int mprotect(void *addr, size_t len, int prot);

      /**
       ,* @brief flush the changes to the file that backs the mapping
       ,*
       ,* @param  flags   MS_ASYNC: schedule the page to be written
       ,*                 MS_SYNC:  wait for the writes to be cmoplete before turning
       ,*
       ,* @warning either MS_ASYNC or MS_SYNC must be specified
       ,*
       ,* @retval 0     OK
       ,* @retval -1    error
       ,*/
      int msync(void *addr, size_t len, int flags);
    #+end_src

    #+caption: Figure 14.29 Timing results comparing read/write versus mmap/memcpy
    [[file:Chapter14/14fig28.jpg]]

*** DONE 14.9 Summary
    CLOSED: [2019-12-29 Sun 02:15]

    - Exercises

      - 14.1

        #+include: "Chapter14/14ex01.c" src c

      - 14.2

        #+begin_quote
        Most systems define the fd_set data type to be a structure that contains a single member: an array of long integers. One bit in this array corresponds to each descriptor. The four FD_ macros then manipulate this array of longs, turning specific bits on and off and testing specific bits.

        One reason that the data type is defined to be a structure containing an array and not simply an array is to allow variables of type fd_set to be assigned to one another with the C assignment statement.
        #+end_quote

      - 14.3

        define or redefine(undefine first) the macro =FD_SETSIZE= (or =__FD_SETSIZE=)

      - 14.4

        | file descriptor sets | signal sets |
        |----------------------+-------------|
        | FD_ZERO              | sigemptyset |
        | FD_SET               | sigaddset   |
        | FD_CLR               | sigdelset   |
        | FD_ISSET             | sigismember |

      - 14.5

        #+include: "Chapter14/14ex05.c" src c

      - 14.6

        No. *call ~fork~ releases all the locks in the child, so the child can't start off with any locks of its own*

      - 14.7

        #+include: "Chapter14/14ex07.c" src c
        #+begin_quote
        | Platform           | Pipe Capacity(bytes) |
        |--------------------+----------------------|
        | FreeBSD 8.0        |                65536 |
        | *Linux 4.1.0*      |                65536 |
        | *Mac OS X 10.15.2* |                65536 |
        | Solaris 10         |                16384 |

        These values can differ from the corresponding =PIPE_BUF= values, because PIPE_BUF is defined to be the maximum amount of data that *can be written* to a pipe atomically. Here, we calculate the amount of data that a pipe *can hold* independent of any atomicity constraints.
        #+end_quote

      - 14.8

        #+include: "Chapter14/14ex08.c" src c

      - 14.9

        just try to execute the program with a very large file

      - 14.10

        Not changed

      - 14.11

        #+include: "Chapter14/14ex11.c" src c

** DONE Chapter 15. Interprocess Communication [12/12]
   CLOSED: [2020-02-06 Thu 15:24]

*** DONE 15.1 Introduction
    CLOSED: [2020-01-03 Fri 19:27]
    #+caption: Figure 15.1 Summary of UNIX System IPC
    | IPC type                   | SUS         | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
    |----------------------------+-------------+-------------+-------------+-----------------+------------|
    | half-duplex pipes          | *           | (full)      | *           | *               | (full)     |
    | FIFOs                      | *           | *           | *           | *               | *          |
    |----------------------------+-------------+-------------+-------------+-----------------+------------|
    | full-duplex pipes          | allowed     | *, UDS      | UDS         | UDS             | *, UDS     |
    | named full-duplex pipes    | obsolescent | UDS         | UDS         | UDS             | *, UDS     |
    |----------------------------+-------------+-------------+-------------+-----------------+------------|
    | XSI message queues         | XSI         | *           | *           | *               | *          |
    | XSI semaphores             | XSI         | *           | *           | *               | *          |
    | XSI shared memory          | XSI         | *           | *           | *               | *          |
    |----------------------------+-------------+-------------+-------------+-----------------+------------|
    | message queues (real-time) | MSG option  | *           | *           |                 | *          |
    | semaphores                 | *           | *           | *           | *               | *          |
    | shared memory  (real-time) | SHM option  | *           | *           | *               | *          |
    |----------------------------+-------------+-------------+-------------+-----------------+------------|
    | sockets                    | *           | *           | *           | *               | *          |
    | STREAMS                    | obsolescent |             |             |                 | *          |

*** DONE 15.2 Pipes
    CLOSED: [2020-01-07 Tue 17:18]
    Limitations:
    1. for maximum protability, we should never assume that ful-duplex pipes is the case
    2. pipes can be used only between proesses that have a common ancestor.

    #+begin_src c
      #include <unistd.h.>
      /**
       ,* @brief create pipe
       ,*
       ,* @param  fd[0]  open for reading
       ,*         fd[1]  open for writing
       ,*
       ,* @retval 0     OK
       ,* @retval -1    error
       ,*/
      int pipe(int fd[2]);
    #+end_src

    #+caption: Figure 15.2 Two ways to view a half-duplex pipe
    [[file:Chapter15/15fig02.jpg]]

    #+caption: Figure 15.3 Half-duplex pipe after a fork
    [[file:Chapter15/15fig03.jpg]]

    #+caption: Figure 15.4 Pipe from parent to child
    [[file:Chapter15/15fig04.jpg]]

    the parent closes fd[1], and the child closes fd[0].

    #+begin_quote
    When one end of a pipe is closed, two rules apply.
    1. If we read from a pipe whose write end has been closed, read returns 0 to indicate an EOF *after* all data has been read.
    2. If we write to a pipe whose read end has been closed, the signal SIGPIPE is generated. If we either ignore the signal or catch it and return from the signal handler, write returns -1 with errno set to EPIPE.
    #+end_quote

    the constant =PIPE_BUF= specifies the kernel's pipe buffer size.

    - Example

      #+caption: Figure 15.5 Send data from parent to child over a pipe
      #+include: "Chapter15/15fig05.c" src c

      #+caption: Figure 15.6 Copy file to pager program
      #+include: "Chapter15/15fig06.c" src c

      #+caption: Figure 15.7 Routine to let a parent and child synchronized
      #+include: "Chapter15/15fig07.c" src c

    #+caption: Figure 15.8 Using two pipes for parent-child synchronization
    [[file:Chapter15/15fig08.jpg]]

*** DONE 15.3 ~popen~ and ~pclose~ Functions
    CLOSED: [2020-01-07 Tue 21:54]
    #+begin_quote
    creating a pipe, forking a child, closing the unused ends of the pipe, executing a shell to run the command, and waiting for the command to terminate.
    #+end_quote
    #+begin_src c
      #include <stdio.h>
      /**
       ,*  @brief        fork(), then exec() the cmdstring,
       ,*
       ,*  @details      and returns a stdio pointer.
       ,*
       ,*  @param[in]    cmdstring    cmd to execute
       ,*  @param[in]    type         "r", connect to stdout
       ,*                             "w", connect to stdin
       ,*  @return       file pointer if OK, NULL on error
       ,*/
      FILE *popen(const char *cmdstring, const char *type);

      /**
       ,* @brief      close the stdio stream,
       ,*
       ,* @details    waits for the cmd to terminate, and
       ,*             returns termination status of the shell
       ,*
       ,* @param      fp             returned by popen
       ,*
       ,* @return     termination status of cmdstring, or -1 on error
       ,*/
      int pclose(FILE *fp);
    #+end_src
    ~type == "r"~:
    #+caption: Figure 15.9 Result of fp = popen(cmdstring, "r");
    [[file:Chapter15/15fig09.jpg]]
    ~type == "w"~:
    #+caption: Figure 15.10 Result of fp = popen(cmdstring, "w");
    [[file:Chapter15/15fig10.jpg]]

    The /cmdstring/ is executed by bash, as in
    #+begin_src bash
      sh -c cmdstring
    #+end_src

    - Example

      #+caption: Figure 15.11 Copy file to pager program using ~popen~
      #+include: "Chapter15/15fig11.c" src c

      #+caption: Figure 15.12 The ~popen~ and ~pclose~ functions
      #+include: "Chapter15/15fig12.c" src c

      #+caption: Figure 15.13 Transforming input using ~popen~
      [[file:Chapter15/15fig13.jpg]]

      #+caption: Figure 15.14 Filter to convert uppercase characters to lowercase
      #+include: "Chapter15/15fig14.c" src c

      #+caption: Figure 15.15 Invoke uppercase/lowercase filter to read commands
      #+include: "Chapter15/15fig15.c" src c

*** DONE 15.4 Coprocesses
    CLOSED: [2020-01-08 Wed 17:57]
    #+begin_quote
    A filter becomes a /coprocess/ when the same program generates the filter's input and reads the filter's output.
    #+end_quote

    - Example

      #+caption: Figure 15.16 Driving a coprocess by writing its standard input and reading its standard output.
      [[file:Chapter15/15fig16.jpg]]

      #+caption: Figure 15.17 Simple filter to add two numbers
      #+include: "Chapter15/15fig17.c" src c

      #+caption: Figure 15.18 Program to drive the 15fig17 filter
      #+include: "Chapter15/15fig18.c" src c

      #+caption: Figure 15.19 Filter to add two numbers, using standard I/O
      #+include: "Chapter15/15fig19.c" src c

*** DONE 15.5 FIFOs
    CLOSED: [2020-01-09 Thu 16:22]
    named pipe. with FIFOs, unrelated processes can exchange data.
    #+begin_src c
      #include <sys/stat.h>
      int mkfifo(const char *path, mode_t mode);
      int mkfifoat(int fd, const char *path, mode_t mode);
      // Both return: 0 if OK, -1 on error
    #+end_src
    three case for mkfifoat;
    1. If the /path/ parameter specifies an absolute pathname, then the /fd/ parameter is ignored and the ~mkfifoat~ function behaves like the mkfifo function.
    2. If the /path/ parameter specifies a relative pathname and the /fd/ parameter is a valid file descriptor for an open directory, the pathname is evaluated relative to this directory.
    3. If the /path/ parameter specifies a relative pathname and the /fd/ parameter has the special value with AT_FDCWD, the pathname is evaluated starting in the current working directory, and the ~mkfifoat~ behaves like ~mkfifo~.

    When we ~open~ a FIFO, the nonblocking flag (=O_NONBLOCK=) affects what happens.
    * In the normal case (without =O_NONBLOCK=), an ~open~ for read-only blocks until some other processes opens the FIFO for writing .
    * If =O_NONBLOCK= is specified, an ~open~ for read-only returns immediately. But an ~open~ for write-only returns -1 with errno set to =ENXIO= if no process has the FIFO open for reading.

    - Example - Using FIFOs to Duplicate Output Streams

      #+caption: Figure 15.20 Procedure that preocesses a filtered input stream twice
      [[file:Chapter15/15fig20.jpg]]

    #+begin_src sh
      mkfifo fifo1
      prog3 < fifo1 &
      prog1 < infile | tee fifo1 | prog2
    #+end_src
    #+caption: Figure 15.21 Using a FIFO and tee to send a stream to two different processes
    [[file:Chapter15/15fig21.jpg]]

    - Example - Clent-Server Communication Using a FIFO

      #+caption: Figure 15.22 Clients sending requests to a server using a FIFO
      [[file:Chapter15/15fig22.jpg]]

      #+caption: Figure 15.23 Client-server communication using FIFOs
      [[file:Chapter15/15fig23.jpg]]

*** DONE 15.6 XSI IPC [4/4]
    CLOSED: [2020-01-09 Thu 18:20]

**** DONE 15.6.1 Identifiers and Keys
     CLOSED: [2020-01-09 Thu 16:51]
     The identifier is an internal name for an IPC object. an IPC object is associated with a /key/ that acts as an external name for cooperating processes to be able to rendezvous using the same IPC object.

     *Whenever an IPC structure is being created, a key (<sys/types.h>::key_st) must be specified.*

     ways for a client and a server to rendezvous at the same IPC structure.
     1. The server can create a new IPC structure by specifying a key of =IPC_PRIVATE= and store the returned identifier somewhere (such as a file) for the client to obtain.
     2. The client and the server can agree on a key by defining the key in a common header.
     3. The client and the server can agree on a pathname and project ID (the project ID is a character value between 0 and 255) and call the function ~ftok~ to convert these two values into a key.

     #+begin_src c
       #include <sys/ipc.h>
       /// @brief generating a key from a pathname and project ID
       ///
       /// @param path        refer to an existing file
       /// @param id          only lower 8 bits used
       ///
       /// @note              usually formed by taking part of st_dev and st_ino fields in stat structure
       key_t ftok(const char *path, int id);
       // Returns: key if OK, (key_t)-1 on error
     #+end_src

     #+begin_quote
     If we want to create a new IPC structure, making sure that we don't reference an existing one with the same identifier, we must specify a /flag/ with both the =IPC_CREAT= and =IPC_EXCL= bits set. Doing this causes an error returned of EEXIST if the IPC structure already exists.
     #+end_quote

**** DONE 15.6.2 Permission Structure
     CLOSED: [2020-01-09 Thu 16:55]
     #+begin_src c
       struct ipc_perm {
               uid_t           uid;            /* [XSI] Owner's user ID */
               gid_t           gid;            /* [XSI] Owner's group ID */
               uid_t           cuid;           /* [XSI] Creator's user ID */
               gid_t           cgid;           /* [XSI] Creator's group ID */
               mode_t          mode;           /* [XSI] Read/write permission */
               // ... more additional members depends on system
       };
     #+end_src

     #+caption: Figure 15.24 XSI IPC permissions
     [[file:Chapter15/15fig24.jpg]]

**** DONE 15.6.3 Configuration Limits
     CLOSED: [2020-01-09 Thu 16:58]
     modify kernel configuration parameters:
     | system     | cmd    |
     |------------+--------|
     | FreeBSD    | sysctl |
     | Linux      | sysctl |
     | Mac OS X   | sysctl |
     | Solaris 10 | prctl  |

     display the IPC-related limits:
     | system   | cmd         |
     |----------+-------------|
     | Linux    | ~ipcs -l~   |
     | Mac OS X | ~ipcs -T~   |
     | FreeBSD  | ~icps -T~   |
     | Solaris  | ~sysdef -i~ |

**** DONE 15.6.4 Advantages and Disadvantages
     CLOSED: [2020-01-09 Thu 18:20]
     * all forms of XSI IPC remain in existence even when no process is using them.
     * we can't see the IPC objects with an ~ls~ command, can't remove them with the ~rm~ command, can't change their permissions with ~chmod~ command. use ~ipcs~ and ~ipcrm~ instead.
     * since they don't use file descriptors, we can't use multiplexed I/O functions(~select~, ~poll~, ~epoll~) with them.

     #+caption: Figure 15.25 Comparison of features of various forms of IPC
     | IPC type                    | Connectionless? | Reliable? | Flow control? | Records? | Message types or priorties? |
     |-----------------------------+-----------------+-----------+---------------+----------+-----------------------------|
     | message queues              | no              | yes       | yes           | yes      | yes                         |
     | STREAMS                     | no              | yes       | yes           | yes      | yes                         |
     | UNIX domain stream socket   | no              | yes       | yes           | no       | no                          |
     | UNIX domain datagram socket | yes             | yes       | no            | yes      | no                          |
     | FIFOs (non-STREAMS)         | no              | yes       | yes           | no       | no                          |

*** DONE 15.7 Message Queues
    CLOSED: [2020-01-09 Thu 20:48]
    A message queue is a linked list of messages stored within the kernel and identified by a message queue identifer.
    #+begin_src c
      struct msqid_ds {
              struct ipc_perm  msg_perm;     /* see Section 15.6.2      */
              msgqnum_t        msg_qnum;     /* # of messages on queue  */
              msglen_t         msg_qbytes;   /* max # of bytes on queue */
              pid_t            msg_lspid;    /* pid of last msgsnd()    */
              pid_t            msg_lrpid;    /* pid of last msgrcv()    */
              time_t           msg_stime;    /* last-msgsnd() time      */
              time_t           msg_rtime;    /* last-msgrcv() time      */
              time_t           msg_ctime;    /* last-change time        */
              .
              .
              .
      };
    #+end_src

    #+caption: Figure 15.26 System limits that affect message queues
    [[file:Chapter15/15fig26.jpg]]

    message queue related functions:
    #+begin_src c
      #include <sys/msg.h>
      /**
       ,* @brief either open an existing queue or create a new queue
       ,*
       ,* * The ipc_perm structure is initialized .
       ,* * msg_qnum,msg_lspid,msg_lrpid,msg_stime, and msg_rtime set to 0
       ,* * msg_ctime is set to the current time
       ,* * msg_qbytes is set to the system limit
       ,*
       ,* @retval msqID  OK
       ,* @retval -1     error
       ,*/
      int msgget(key_t key, int flag);

      /**
       ,* @brief ioctl-like functions for XSI IPC
       ,*
       ,* * IPC_STAT fetch the msqid_ds structure for this queue
       ,* * IPC_SET copy the following fields from the structure pointed to by buf to
       ,* the msqid_ds
       ,* * IPC_RMID remove the message queue from the system and any data still on the
       ,* queue.
       ,*
       ,* @retval 0     OK
       ,* @retval -1    error
       ,*/
      int msgctl(int msqid, int cmd, struct msqid_ds *buf);

      /**
       ,* @brief data is placed on a message queue by calling msgsnd.
       ,*
       ,* messages are always placed at the end of the queue.
       ,* * IPC_NOWAIT can be specified, this is similar to the nonblocking I/O flag
       ,* for file I/O.
       ,*
       ,* @retval 0 OK
       ,* @retval -1 error
       ,*/
      int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);

      /**
       ,* @brief messages are retrieved from a queue by msgrcv.
       ,*
       ,* * type == 0 the first message on the queue is returned
       ,* * type > 0  the first message on the queue whose message type equals type is
       ,* returned.
       ,* * type < 0  the fire message on the queue whose message type is the lowest
       ,* values less than or equal to the absolute value of type is returned.
       ,*
       ,* @return sizeof data portion of message if OK, -1 on error
       ,*/
      ssize_t msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);
    #+end_src

    - Example - Timing Comparison of Message Queues and Full-Duplex Pipes.

      #+caption: Figure 15.27 Timing comparison of IPC alternatives on Solaris
      | Operation          | User | Systems | Clock |
      |--------------------+------+---------+-------|
      | message queue      | 0.58 |    4.16 |  5.09 |
      | full-duplex pipe   | 0.61 |    4.30 |  5.24 |
      | UNIX domain socket | 0.59 |    5.58 |  7.49 |

*** DONE 15.8 Semaphores
    CLOSED: [2020-01-10 Fri 17:40]
    A semaphore is a counter used to provide access to a shared data object for multiple processes.
    obtain a shared resource:
    1. Test the semaphore that controls the resource.
    2. If the value of the semaphore is positive, the process can use the resource.
    3. Otherwise, if the value of the semaphore is 0, the process goes to sleep until the semaphore value is greater than 0.

    XSI semaphores :
    1. A semaphore is not simply a single non-negative value.
    2. The creation of a semaphore (~semget~) is independent of its initialization (~semctl~).
    3. Since all forms of XSI IPC remain in existence even when no process is using them, we have to worry about a program that terminates without releasing the semaphores it has been allocated.

    The kernel maintains a =semid_ds= structure for each semaphore set:
    #+begin_src c
      struct semid_ds {
              struct ipc_perm sem_perm;  // see Section 15.6.2
              unsigned short  sem_nsems; // # of semaphores in set
              time_t          sem_otime; // last-semop time
              time_t          sem_ctime; // last-change time
              .
              .
              .
      };
    #+end_src

    Each semaphore is represented by an anonymous structure containing at least the following members:
    #+begin_src c
      struct {
              unsigned short semval;          // semaphore value, alwyas >= 0
              pid_t          sempid;          // pid for last operation
              unsigned short semncnt;         // # processes awaiting semval > curval
              unsigned short semzcnt;         // # processes awaiting semval == 0
              .
              .
              .
      };
    #+end_src

    #+caption: Figure 15.28 System limits that affect semaphores
    [[file:Chapter15/15fig28.jpg]]

    XSI semaphores using:
    #+begin_src c
      #include <sys/sem.h>
      /**
       ,* @brief obtain a semaphore ID
       ,*
       ,* * ipc_perm structure is initialized, the mode member depends on perssion bits of flag.
       ,* * sem_otime is set to 0.
       ,* * sem_ctime is set to the current time.
       ,* * sem_nsems is set to the nsems.
       ,*
       ,* @param    nsems      the number of semaphores
       ,*
       ,* @return   semaphore ID if OK, -1 on error
       ,*/
      int semget(key_t key, int nsems, int flag);

      /**
       ,*  @brief catchall for various semaphore operations
       ,*
       ,* A union of various command-specific arguments.
       ,* union semun {
       ,*    int              val;     // for SETVAL
       ,*    struct semid_ds *buf;     // for IPC_STAT and IPC_SET
       ,*    unsigned short  *array;   // for GETALL and SETALL
       ,* };
       ,* The optional argument is the actual union, not a pointer to the union.
       ,*
       ,* @param   semid   set specified semaphore
       ,* @param   cmd     specifies one of the following ten commands to be performed
       ,*                  IPC_STAT    fetch semid_ds structure for this set
       ,*                  IPC_SET     set the sem_perm.uid,sem_perm.gid, and sem_perm.mode
       ,*                  IPC_RMID    remove the semaphore from the system.
       ,*                  GETVAL      return the value of semval for the member semnum;
       ,*                  SETVAL      set the value of semval for the member semnum.
       ,*                  GETPID      get the value of sempid
       ,*                  GETNCNT     return the value of semncnt for the member semnum.
       ,*                  GETZCNT     return the value of semzcnt for the member semnum.
       ,*                  GETALL      fetch all the semaphore values in the set.
       ,*                  SETALL      set all the semaphore values in the set to the values pointed to by arg array.
       ,* @return   for all the GET commands other than GETALL, see above for details,
       ,*          otherwise, 0 if OK, -1 on error and set errno
       ,*/
      int semctl(int semid, int semnum, int cmd, ... /* union semun arg */);

      /**
       ,* @brief atomically performs an array of operations on a semaphore set
       ,*
       ,* struct sembuf {
       ,*     unsigned short sem_num;  // member # in set (0, 1, ... nsems-1);
       ,*     short          sem_op;   // operation(negative, 0, or positive);
       ,*     short          sem_flg;  // IPC_NOWAIT, SEM_UNDO
       ,* };
       ,* see following for details
       ,*
       ,* @return 0 if OK, -1 on error
       ,*/
      int semop(int semid, struct sembuf semoparray[], size_t nops);
    #+end_src

    sem_op value effects:
    #+begin_quote
    1. The easiest case is when sem_op is positive. This case corresponds to the returning of resources by the process. The value of sem_op is added to the semaphore’s value. If the undo flag is specified, sem_op is also subtracted from the semaphore’s adjustment value for this process.

    2. If sem_op is negative, we want to obtain resources that the semaphore controls.

       If the semaphore’s value is greater than or equal to the absolute value of sem_op (the resources are available), the absolute value of sem_op is subtracted from the semaphore’s value. This guarantees the resulting semaphore value is greater than or equal to 0. If the undo flag is specified, the absolute value of sem_op is also added to the semaphore’s adjustment value for this process.

       If the semaphore’s value is less than the absolute value of sem_op (the resources are not available), the following conditions apply.

       + If IPC_NOWAIT is specified, semop returns with an error of EAGAIN.

       + If IPC_NOWAIT is not specified, the semncnt value for this semaphore is incremented (since the caller is about to go to sleep), and the calling process is suspended until one of the following occurs.

         - The semaphore’s value becomes greater than or equal to the absolute value of sem_op (i.e., some other process has released some resources). The value of semncnt for this semaphore is decremented (since the calling process is done waiting), and the absolute value of sem_op is subtracted from the semaphore’s value. If the undo flag is specified, the absolute value of sem_op is also added to the semaphore’s adjustment value for this process.

         - The semaphore is removed from the system. In this case, the function returns an error of EIDRM.

         - A signal is caught by the process, and the signal handler returns. In this case, the value of semncnt for this semaphore is decremented (since the calling process is no longer waiting), and the function returns an error of EINTR.

    3. If sem_op is 0, this means that the calling process wants to wait until the semaphore’s value becomes 0.

       If the semaphore’s value is currently 0, the function returns immediately.

       If the semaphore’s value is nonzero, the following conditions apply.

       + If IPC_NOWAIT is specified, return is made with an error of EAGAIN.

       + If IPC_NOWAIT is not specified, the semzcnt value for this semaphore is incremented (since the caller is about to go to sleep), and the calling process is suspended until one of the following occurs.

         - The semaphore’s value becomes 0. The value of semzcnt for this semaphore is decremented (since the calling process is done waiting).

         - The semaphore is removed from the system. In this case, the function returns an error of EIDRM.

         - A signal is caught by the process, and the signal handler returns. In this case, the value of semzcnt for this semaphore is decremented (since the calling process is no longer waiting), and the function returns an error of EINTR.

    #+end_quote

    - Semaphore Adjustment on exit

      using ~semctl~ with either =SETVAL= or =SETALL= commands, the adjustment value for that semaphore in all processes is set to 0

      - Example - Timing Comparison of Semaphores, Record Locking, and Mutexes

        #+caption: Figure 15.29 Timing comparison of locking alternatives on Linux
        | Operation               | User | System | Clock |
        |-------------------------+------+--------+-------|
        | semaphores with undo    | 0.50 |   6.08 |  7.55 |
        | advisory record locking | 0.51 |   9.06 |  4.38 |
        | mutex in shared memory  | 0.21 |   0.40 |  0.25 |

        with locking single resource and don't need all the features of XSI semaphores, record locking is preferable, cause that is much simpler to use and system take care of any lingering locks when process terminates.
        unless performance is the primary concerned, record locking is still more preferable than mutex (1. easier to use, 2. cross-platform support)

*** DONE 15.9 Shared Memory
    CLOSED: [2020-01-10 Fri 21:54]
    Shared memory allows two or more processes to share a given region of memory. This is the *fastest* form of IPC.
    #+begin_src c
      struct shmid_ds {
              struct ipc_perm shm_per;     // see Section 15.6.2
              size_t          shm_segsz;   // sizeof segment in bytes
              pid_t           shm_lpid;    // pid of last shmop()
              pid_t           shm_cpid;    // pid of creator
              shmatt_t        shm_nattch;  // number of current attaches, shmatt_t is defined to be an unsigned short
              time_t          shm_atime;   // last-attach time
              time_t          shm_dtime;   // last-detach time
              time_t          shm_ctime;   // last-change time
              ...
      };
    #+end_src

    #+caption: Figure 15.30 System limits that affect shared memory
    [[file:Chapter15/15fig30.jpg]]

    Shared memory API:
    #+begin_src c
      #include <sys/shm.h>
      /**
       ,* @brief      obtain a shared memory identifier
       ,*
       ,* @details    the following members of shmid_ds structure are initialized.
       ,*             * ipc_perm
       ,*             * shm_lpid,shm_nattch,shm_atime, and shm_dtime are all set to 0
       ,*             * shm_ctime is set to the current time
       ,*             * shm_segsz is set to the size requested
       ,*
       ,* @param[in]  key    for converting into an identifier
       ,* @param[in]  size   the size of the shared memory segment in bytes
       ,* @param[in]  flag   for ipc_perm's permission bits set
       ,*
       ,* @return     shared memory ID if OK, -1 on error
       ,*/
      int shmget(key_t key, size_t size, int flag);

      /**
       ,* @brief      catchall for various shared memory operations
       ,*
       ,* @param[in]  shmid      speicify which shared memory to operate
       ,* @param[in]  cmd        IPC_STAT    fetch the shmid_ds structure for this segment, storing to buf
       ,*                        IPC_SET     set the following three fields from buf
       ,*                                    shm_perm.uid,shm_perm.gid,shm_perm.mode
       ,*                                    can be only executed by UID == shm_perm.cuid or shm_perm.uid or root
       ,*                        IPC_RMID    remove the shared memory segment set from the system
       ,*                                    actually it is attachment count decrease 1
       ,*                                    be removed until the last process using the segment terminates or detaches it .
       ,*                                    regardless of whether the segment is still in use
       ,*                                    can be only executed by UID == shm_perm.cuid or shm_perm.uid or root.
       ,*                        additional commands for Linux and Solaris only
       ,*                        SHM_LOCK    lock the shared memory
       ,*                        SHM_UNLOCK  unlock the shared memory
       ,* @param[in,out] buf     read or write, depends on cmd specified
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int shmctl(int shmid, int cmd, struct shmid_ds *buf);

      /**
       ,* @brief      a process attach a existing shared memory segment.
       ,*
       ,* @details
       ,*
       ,* @param[in]  shmid      specify which shared memory segment to attach
       ,* @param[in]  addr       is 0, the segment is attached at the first available address selected by the kernel.
       ,*                        is nonzero and SHM_RND is not specified, the segment is attached at addr
       ,*                        is nonzero and SHM_RND is specified, attached at (addr - (addr modulus SHMLBA)),
       ,*                          SHMLBA stands for "low boundary address multiple" and is always a power of 2.
       ,*                          round the address down to the next multiple of SHMLBA.
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int shmat(int shmid, const void *addr, int flag);

      /**
       ,* @brief      detach a shared memory segment.
       ,*
       ,* @details    this DOES NOT removed the identifier and associated data structure
       ,*             the identifier remains in existence until removes by calling shmctl with IPC_RMID.
       ,*
       ,* @param      addr to detach
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int shmdt(const void *addr);
    #+end_src

    - Example

      #+caption: Figure 15.31 Print where various types of data are stored
      #+include: "Chapter15/15fig31.c" src c
    #+begin_quote
    Results on Linux:

    array[] from 0x602540 to 0x60c180

    stack around 0x7ffdaff9121c

    malloced from 0xd2c010 to 0xd446b0

    shared memory attached from 0x7f40d9097000 to 0x7f40d90af6a0
    #+end_quote
    #+begin_quote
    Results on Mac OS X

    array[] from 0x102d40090 to 0x102d49cd0

    stack around 0x7ffeecec2438

    malloced from 0x102d60000 to 0x102d786a0

    shared memory attached from 0x102d7a000 to 0x102d926a0
    #+end_quote
    #+caption: Figure 15.32 Memory layout on an Intel-based Linux system.
    [[file:Chapter15/15fig32.jpg]]

    - Example - Memory Mapping of /dev/zero

      techinque for related processes
      * An unnamed memory region is created whose size is the second argument to mmap, rounded up to the nearest page size on the system.
      * The memory region is initialized to 0.
      * Multiple processes can share this region if a common ancestor specifies the MAP_SHARED flag to mmap.

      #+caption: Figure 15.33 IPC between parent and child using memory mapped I/O of /dev/zero
      #+include: "Chapter15/15fig33.c" src c

    - Example - Anonymous Memory Mapping

      To use this facility, specify =MAP_ANONYMOUS= (=MAP_ANON= deprecated on Linux) flag to ~mmap~ and specify the fd to -1.
      #+caption: modify [[file:Chapter15/15fig33.c::/**][Figure 15.33]] to use this facility
      #+include: "Chapter15/15fig33a.c" src c

*** DONE 15.10 POSIX Semaphores
    CLOSED: [2020-01-11 Sat 22:02]
    The POSIX semaphore mechanism is one of three IPC mechanisms that originated with the real-time extensions to POSIX.1.

    The POSIX semaphore interfaces were meant to address several deficiencies with the XSI semaphore interfaces:
    * The POSIX semaphore interfaces allow for higher-performance implementations compared to XSI semaphores.
    * The POSIX semaphore interfaces are simpler to use: no semaphore sets, and several of the interfaces are patterned after familiar file system operations.
    * The POSIX semaphores behave more gracefully when removed.

    APIs:
    #+begin_src c
      #include <semaphore.h>
      /**
       ,* @brief      create a new named semaphore or use an existing one
       ,*
       ,* @return     Pointer to semaphore if OK, SEM_FAILED on error
       ,*
       ,* @note       To promote portability
       ,* * The first character in the name should be a slash
       ,* * The name should contain no other slashes to avoid implementation-defined
       ,* behavior.
       ,* * The maximum length of the semaphore name is implementation defined.
       ,*/
      sem_t *sem_open(const char *name, int oflag,
                      ... /* mode_t mode, unsigned int value */);

      /**
       ,* @brief      release any resources associated with the semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int sem_close(sem_t *sem);

      /**
       ,* @brief      remove the name of the semaphore.
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int sem_unlink(const char *name);

      /**
       ,* @brief      decrement the value of a semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,* @note       avoids blocking if the semaphore count is 0
       ,*/
      int sem_trywait(sem_t *sem);
      /**
       ,* @brief      decrement the value of a semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,* @note       blocks if the semaphore count is 0.
       ,*/
      int sem_wait(sem_t *sem);

      /**
       ,* @brief      block for a bounded amount of time
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      #include <time.h>
      int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict tsptr);

      /**
       ,* @brief      increment the value of a semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int sem_post(sem_t *sem);

      /**
       ,* @brief      create an unnamed semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int sem_init(sem_t *sem, int pshared, unsigned int value);

      /**
       ,* @brief      discard an unnamed semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int sem_destroy(sem_t *sem);

      /**
       ,* @brief      retrieve the value of a semaphore
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int sem_getvalue(sem_t *restrict sem, int *restrict valp);
    #+end_src

    - Example

      #+caption: Figure 15.34 Timing comparison of semaphore implementation
      [[file:Chapter15/15fig34.jpg]]

      #+caption: Figure 15.35 Mutual exclusion using a POSIX semaphore
      #+include: "Chapter15/15fig35.c" src c

*** DONE 15.11 Client-Server Properties
    CLOSED: [2020-01-12 Sun 23:47]
    *A child cannot pass a descriptor back to the parent (unless special programming techniques are used, which we cover in Chapter 17).*

    Message queue(Either of these two techniques using message queue can be implemented using shared memory and a synchronization method) :
    1. A single queue can be used between the srever and all the clients, using the type field of each mesage to indicate the message recipient.
    2. Alternatively, an individual message queue can be used for each client.

*** DONE 15.12 Summary
    CLOSED: [2020-02-06 Thu 15:24]

    - Exercises

      - 15.1 pager program blocks

        #+include: "Chapter15/15ex01.c" src c

      - 15.2

        #+begin_quote
        The parent terminates right after writing the last line to the pipe. The read end of the pipe is automatically closed when the parent terminates. But the parent is probably running ahead of the child by one pipe buffer, since the child (the pager program) is waiting for us to look at a page of output. If we’re running a shell, such as the Korn shell, with interactive command-line editing enabled, the shell probably changes the terminal mode when our parent terminates and the shell prints a prompt. This undoubtedly interferes with the pager program, which has also modified the terminal mode. (Most pager programs set the terminal to noncanonical mode when awaiting input to proceed to the next page.)
        #+end_quote
        #+include: "Chapter15/15ex02.c" src c

      - 15.3 cannot execute the non-existent command

        #+include: "Chapter15/15ex03.c" src c
        #+RESULTS:
        sh: ./a.out: No such file or directory
        #+begin_quote
        pclose returns the termination status of the command as it is returned by waitpid.
        #+end_quote

      - 15.4

        #+begin_quote
        When the parent terminates, look at its termination status with the shell. For the Bourne shell, Bourne-again shell, and Korn shell, the command is echo $?. The number printed is 128 plus the signal number.
        #+end_quote
        #+RESULTS:
        ➜   echo $?
        141

      - 15.5

        #+include: "Chapter15/15ex05.c" src c

      - 15.6

        The wait function catch the child that popen function generated because we can't distinguish which is the child we want.
        #+begin_quote
        The system function calls wait, and the first child to terminate is the child generated by popen. Since that’s not the child that system created, it calls wait again and blocks until the sleep is done. Then system returns. When pclose calls wait, an error is returned, since there are no more children to wait for. Then pclose returns an error.
        #+end_quote

      - 15.7

        #+include: "Chapter15/15ex07.c" src c
        The answer gives the following table about various behaviors on different systems, but when I test, it seems different
        #+caption: Figure C.19 Pipe behavior with select and poll
        | Operation                                        | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris |
        |--------------------------------------------------+-------------+-------------+-----------------+---------|
        | select on read end of pipe with write end closed | R/W/E       | R           | R/W             | R/W/E   |
        | poll on read end of pipe with write end closed   | R/HUP       | HUP         | INV             | HUP     |
        | select on write end of pipe with read end closed | R/W/E       | R/W         | R/W             | R/W     |
        | poll on write end of pipe with read end closed   | R/HUP       | W/ERR       | INV             | HUP     |

        #+caption: tested answer
        | Operation                                        | Linux 3.2.0 | Mac OS X 10.6.8 |
        |--------------------------------------------------+-------------+-----------------|
        | select on read end of pipe with write end closed | R/W         | R/W             |
        | select on write end of pipe with read end closed | HUP         | HUP             |

      - 15.8

        parent's standard error appears.

      - 15.9

        ~fork~, then ~exec~, ~waitpid~, ~exit~
        #+begin_quote
        The popen function forks a child, and the child executes the shell. The shell in turn calls fork, and the child of the shell executes the command string. When cmdstring terminates, the shell is waiting for this to happen. The shell then exits, which is what the waitpid in pclose is waiting for.
        #+end_quote

      - 15.10 open twice, and using O_NONBLOCK for reading mode

        #+include: "Chapter15/15ex10.c" src c

      - 15.11

        #+begin_quote
        The identifier of the message queue. The queue would have to allow the appropriate level of access (probably world-read, for a random malicious process). It would interfere with the running of the server/clients though, because each would probably be expecting messages to exist on the queue that aren't there.
        #+end_quote

      - 15.12

        #+include: "Chapter15/15ex12.c" src c

      - 15.13 The actual addresses are different for different processes, so we need to store offsets instead.

        #+begin_quote
        We never store actual addresses in a shared memory segment, since it’s possible for the server and all the clients to attach the segment at different addresses. Instead, when a linked list is built in a shared memory segment, the list pointers should be stored as offsets to other objects in the shared memory segment. These offsets are formed by subtracting the start of the shared memory segment from the actual address of the object.
        #+end_quote

      - 15.14

        [[file:Chapter15/15ex14.jpg]]

      - 15.15

        #+include: "Chapter15/15ex15.c" src c

      - 15.16 it's not shared memory

        #+include: "Chapter15/15ex16.c" src c

      - 15.17 it's not shared memory

        #+include: "Chapter15/15ex17.c" src c

      - 15.18 it's not shared memory

        #+include: "Chapter15/15ex18.c" src c

** DONE Chapter 16. Network IPC: Sockets [9/9]
   CLOSED: [2020-01-31 Fri 14:51]

*** DONE 16.1 Introduction
    CLOSED: [2020-01-19 Sun 13:50]
    *only an overview of the socket API*

*** DONE 16.2 Socket Descriptors
    CLOSED: [2020-01-19 Sun 20:30]
    #+begin_src c
      #include <sys/socket..h>

      /**
       ,*  @brief create socket
       ,*
       ,*  @param domain   determines the nature of the communication, includes the
       ,*                  address format
       ,*  @param type     determines the type of the socket, which further determine
       ,*                  the communication characteristics
       ,*  @param protocol usually 0, to select the default protocol for the given
       ,*                  domain and socket type. but can select a particular protocol
       ,*
       ,*  @return file (socket) descriptor if OK, -1 on error
       ,*/
      int socket(int domain, int type, int protocol);

      /**
       ,*  @brief diasable I/O on a socket
       ,*  @param sockfd     socket's return value
       ,*  @param how        SHUT_RD,   reading is disabled
       ,*                    SHUT_WR,   writing is disabled
       ,*                    SHUT_RDWR, disable both data transmission and reception
       ,*  @return 0 if OK, -1 on error
       ,*/
      int shutdown(int sockfd, int how);
    #+end_src
    #+caption: Figure 16.1 Socket communication domains
    | Domain    | Description                                |
    |-----------+--------------------------------------------|
    | AF_INET   | IPv4 Internet domain                       |
    | AF_INET6  | IPv6 Internet domain (optional in POSIX.1) |
    | AF_UNIX   | UNIX domain                                |
    | AF_UNSPEC | unspecified                                |

    #+caption: Figure 16.2 Socket types
    | Type           | Description                                                          |
    |----------------+----------------------------------------------------------------------|
    | SOCK_DGRAM     | fix-length, connectionless, unreliable messages                      |
    | SOCK_RAW       | datagram interface to IP (optional in POSIX.1)                       |
    | SOCK_SEQPACKET | fix-length, sequenced, reliable, connection-oriented message         |
    | SOCK_STREAMS   | sequenced, reliable, bidirectional, connection-oriented byte streams |

    #+caption: Figure 16.3 Protocols defined for Internet domain socks
    | Protocol     | Description                                   |
    |--------------+-----------------------------------------------|
    | IPPROTO_IP   | IPv4 Internet Protocol                        |
    | IPPROTO_IPV6 | IPv6 Internet Protocol (optional in POSIX.1)  |
    | IPPROTO_ICMP | Internet Control message Protocol             |
    | IPPROTO_RAW  | Raw IP packets protocol (optional in POSIX.1) |
    | IPPROTO_TCP  | Transmission Control Protocol                 |
    | IPPROTO_UDP  | User Datagram Protocol                        |

    A =SOCK_SEQPACKET= is just like a =SOCK_STREAM= socket except that we get a message-based service instead of a byte-stream service.

    #+caption: Figure 16.4 How file descriptor functions act with sockets
    | Function                                      | Behavior with socket                                                                                                    |
    |-----------------------------------------------+-------------------------------------------------------------------------------------------------------------------------|
    | close(Section 3.3)                            | deallocates the socket                                                                                                  |
    | dup, dup2(Section 3.12)                       | duplicates the file descriptor as normal                                                                                |
    | fchdir (Section 4.23)                         | fails with errno set to ENOTDIR                                                                                         |
    | fchmod (Section 4.9)                          | unspecified                                                                                                             |
    | fchown (Section 4.11)                         | implementation defined                                                                                                  |
    | fcntl (Section 3.14)                          | some commands supported, including F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_GETFL, F_GETOWN, F_SETFD, F_SETFL, and F_SETOWN |
    | fdatasync, fsync (Section 3.13)               | implementation defined                                                                                                  |
    | fstat (Section 4.2)                           | some status structure members supported, but left up to the implementation                                              |
    | ftruncate (Section 4.13)                      | unspecified                                                                                                             |
    | ioctl (Section 3.15)                          | some commands work, depending on underlying device driver                                                               |
    | lseek (Section 3.6)                           | implementation defined (usually fails with errno set to ESPIPE)                                                         |
    | mmap (Section 14.8)                           | unspecified                                                                                                             |
    | poll (Section 14.4.2)                         | works as expected                                                                                                       |
    | pread and pwrite (Section 3.11)               | fails with errno set to ESPIPE                                                                                          |
    | read (Section 3.7) and readv (Section 14.6)   | equivalent to recv (Section 16.5) without any flags                                                                     |
    | select (Section 14.4.1)                       | works as expected                                                                                                       |
    | write (Section 3.8) and writev (Section 14.6) | equivalent to send (Section 16.5) without any flags                                                                     |

*** DONE 16.3 Addressing [4/4]
    CLOSED: [2020-01-23 Thu 18:34]
    :PROPERTIES:
    :ID:       6AA28BE4-0602-4084-AECC-A77FABF38452
    :END:

**** DONE 16.3.1 Byte Ordering
     CLOSED: [2020-01-20 Mon 11:49]
     #+caption: Figure 16.5 Byte order in a 32-bit integer
     [[file:Chapter16/16fig05.jpg]]

     #+caption: Figure 16.6 Byte order for test platforms
     | Operating system | Processor architecture | Byte order    |
     |------------------+------------------------+---------------|
     | FreeBSD 8.0      | Intel Pentium          | little-endian |
     | Linux 3.2.0      | Intel Core i5          | little-endian |
     | Mac OS X 10.6.8  | Intel Core 2 Duo       | little-endian |
     | Solaris 10       | Sun SPARC              | big-endian    |

     #+begin_src c
       /**
        ,* functions to convert between the processor byte order
        ,* and the network byte order for TCP/IP applications
        ,*/

       #include <arpa/inet.h>

       /// @return 32-bit integer in network byte order
       uint32_t htonl(uint32_t hostint32);

       /// @return 16-bit integer in network byte order
       uint16_t htons(uint16_t hostint16);

       /// @return 32-bit integer in host byte order
       uint32_t ntohl(uint32_t netint32);

       /// @return 16-bit integer in host byte order
       uint16_t ntohs(uint16_t netint16);
     #+end_src

**** DONE 16.3.2 Address Formats
     CLOSED: [2020-01-21 Tue 19:15]
     #+begin_src c
       // generic sockaddr address structure
       struct sockaddr {
               sa_family_t sa_family;  // address family
               char        sa_data[];  // variable-length address
               ...  // free to add more members and define a size for the sa_data member
       };

       // on Linux
       struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
       };

       // on FreeBSD
       struct sockaddr {
               unsigned char sa_len;       // total length
               sa_family_t   sa_family;    // address family
               char          sa_data[14];  // variable-length address
       };
     #+end_src

     Internet addresses
     #+begin_src c
       #include <netinet/in.h>

       // #include <stdint.h> defined uintxx_t
       typedef uint16_t in_port_t;
       typedef uint32_t in_addr_t;

       // In the IPv4 Internet domain (AF_INET),
       // a socket address is represented by a sockaddr_in structure

       struct in_addr {
               in_addr_t s_addr;  // IPv4 address
       };

       struct sockaddr_in {
               sa_family_t    sin_family;  // address family
               in_port_t      sin_port;    // port number
               struct in_addr sin_addr;    // IPv4 address
       };

       // In the IPv6 Internet domain (AF_INET6)
       // represented by a sockaddr_in6 structure
       struct in6_addr {
               uint8_t s6_addr[16];  // IPv6 address
       };

       struct sockaddr_in6 {
               sa_family_t     sin6_family;    // address family
               in_port_t       sin6_port;      // port number
               uint32_t        sin6_flowinfo;  // traffic class and flow info
               struct in6_addr sin6_addr;      // IPv6 address
               uint32_t        sin6_scope_id;  // set of interfaces for scope
       };

       // on Linux
       struct sockaddr_in {
               sa_family_t    sin_family;   // address family
               in_port_t      sin_port;     // port number
               struct in_addr sin_addr;     // IPv4 address
               unsigned char  sin_zero[8];  // filler
       };
     #+end_src

     convert between the binary address format and a string in dotted-decimal notation.
     #+begin_src c
       #include <arpa/inet.h>

       /**
        ,* @param  domain    AF_INET/AF_INET6 only
        ,*
        ,* @return pointer to address string on success, NULL on error
        ,*/
       const char *inet_ntop(int domain, const void *restrict addr, char *restrict str,
                             socklen_t size);

       /**
        ,* @brief string addr to binary
        ,*
        ,* @param  domain   AF_INET/AF_INET6 only
        ,*
        ,* @return 1 on success, 0 if the format is invalid, or -1 on error
        ,*/
       int inet_pton(int domain, const char *restrict str, void *restrict addr);
     #+end_src

**** DONE 16.3.3 Address Lookup
     CLOSED: [2020-01-22 Wed 00:59]
     get hosts
     #+begin_src c
       #include <netdb.h>

       /**
        ,*  @brief get hosts
        ,*
        ,*  @return pointer if OK, NULL on error
        ,*/
       struct hostent* gethostent(void);

       void sethostent(int stayopen);

       void endhostent(void);

       struct hostent {
               char*  h_name;       // name of host
               char** h_aliases;    // pointer to alternate host name array
               int    h_addrtype;   // address type
               int    h_length;     // length in bytes of address
               char** h_addr_list;  // pointer to array of network addresses
               ...
       };

       #include <netdb.h>
       /**
        ,*  @brief get network info
        ,*
        ,*  a set of interfaces
        ,*
        ,*  @return pointer if OK, NULL on error
        ,*/
       struct netent* getnetbyaddr(uint32_t net, int type);
       struct netent* getnetbyname(const char* name);
       struct netent* getnetent(void);

       void setnetent(int stayopen);
       void endnetent(void);

       struct netent {
               char*    n_name;      // network name
               char**   n_aliases;   // alternate network name array pointer
               int      n_addrtype;  // address type
               uint32_t n_net;       // network number
               ...
       };

       #include <netdb.h>
       /**
        ,* @brief      map between protol names and numbers
        ,*
        ,* @return     pointer if OK, NULL on error
        ,*/
       struct protoent* getprotobyname(const char* name);
       struct protoent* getprotobynumber(int proto);
       struct protoent* getprotoent(void);

       void setprotoent(int stayopen);
       void endprotoent(void);

       struct protoent {
               char*  p_name;     // protocol name
               char** p_aliases;  // pointer to alternate protocol name array
               int    p_proto;    // proto number
               ...
       };

       #include <netdb.h>
       /**
        ,* @brief      a set of services' interfaces
        ,*
        ,*
        ,* @return     pointer if OK, NULL on error
        ,*/
       struct servent* getservbyname(const char* name, const char* proto);
       struct servent* getservbyport(int port, const char* proto);
       struct servent* getservent(void);

       void setservent(int stayopen);
       void endservent(void);

       struct servent {
               char*  s_name;     // service name
               char** s_aliases;  // pointer to alternate srevice name array
               int    s_port;     // port number
               char*  s_proto;    // name of proto
               ...
       };

       #include <netdb.h>
       #include <sys/socket.h>
       /**
        ,* @brief      get address info
        ,*
        ,* @return     0 if OK, nonzero error code on error
        ,*/

       int getaddrinfo(const char* restrict host, const char* restrict service,
                       const struct addrinfo* restrict hint,
                       struct addrinfo** restrict      res);

       void freeaddrinfo(struct addrinfo* ai);

       /**
        ,* @brief      convert the error code into error message
        ,*
        ,* @details    can't use perror or strerror to generate an error message
        ,* but, need to call gai_strerror instead
        ,*
        ,* @param      error code returned by getaddrinfo
        ,*
        ,* @return     a pointer to a string describing the error
        ,*/
       const char* gai_strerror(int error);

       struct addrinfo {
               int              ai_flags;      // customize behavior
               int              ai_family;     // address family
               int              ai_socktype;   // socket type
               int              ai_protocol;   // protocol
               socklen_t        ai_addrlen;    // length in bytes of address
               struct sockaddr* ai_addr;       // address
               char*            ai_canonname;  // canonical name of host
               struct addrinfo* ai_next;       // next in list
               ...
       };

       /**
        ,* @brief      convert an address into host and service name
        ,*
        ,* @return     0 if OK, nonzero on error
        ,*/
       #include <netdb.h>
       #include <sys/socket.h>

       int getnameinfo(const struct sockaddr* restrict addr, socklen_t alen,
                       char* restrict host, socklen_t hostlen, char* restrict service,
                       socklen_t servlen, int flags);
     #+end_src

     #+caption: Figure 16.7 Flags for addrinfo structure
     | Flags          | Description                                                                   |
     |----------------+-------------------------------------------------------------------------------|
     | AI_ADDRCONFIG  | Query for whichever address type (IPv4 or IPv6) is configured.                |
     | AI_ALL         | Look for both IPv4 and IPv6 addresses (used only with AI_V4MAPPED).           |
     | AI_CANONNAME   | Request a canonical name (as opposed to an alias).                            |
     | AI_NUMERICHOST | The host address is specified in numeric format; don't try to translate it.   |
     | AI_NUMERICSERV | The service is specified as a numeric port number, don't try to translate it. |
     | AI_PASSIVE     | Socket address is intended to be bound for listening.                         |
     | AI_V4MAPPED    | If no IPv6 addreses are found, return IPv4 addresses mapped in IPv6 format.   |

     #+caption: Figure 16.8 Flags for the ~getnameinfo ~function
     | Flags           | Description                                                                             |
     |-----------------+-----------------------------------------------------------------------------------------|
     | NI_DGRAM        | The service is datagram based instead of stream based.                                  |
     | NI_NAMEREQD     | If the host name can't be found, treat this as an error.                                |
     | NI_NOFQDN       | Return only the node name portion of the fulling qualified domain name for local hosts. |
     | NI_NUMERICHOST  | Return the numeric form of the host address instead of the name.                        |
     | NI_NUMERICSCOPE | For IPv6, return the numeric form of the scope ID instead of the name.                  |
     | NI_NUMERICSERV  | Return the numeric form of the service address (i.e., the port number)                  |

     #+caption: Figure 16.9 Print host and service information
     #+include: "Chapter16/16fig09.c" src c

**** DONE 16.3.4 Associating Addresses with Sockets
     CLOSED: [2020-01-22 Wed 09:29]
     #+begin_src c
       #include <sys/socket.h>

       /**
        ,* @brief      associate an address with a socket
        ,*
        ,* @param      addr     restrictions:
        ,*                      * The address we specify must be valid for the
        ,* machine on which the process is running; we can't specify an address
        ,* belonging to some other machine
        ,*                      * The address must match the format supported by the
        ,* address family we used to create the socket
        ,*                      * The port number in the address cannot be less than
        ,* 1024 unless the process has the appropriate privilege
        ,*                      * Usually, ony one socket endpoint can be bound to a
        ,* given address, although some protocols allow duplicate bindings.
        ,*
        ,* @return     0 if OK, -1 on error
        ,*/
       int bind(int sockfd, const struct sockaaddr *addr, socklen_t len);

       /**
        ,* @brief      discover the address bound to a socket
        ,*
        ,* @return     0 if OK, -1 on error
        ,*/
       int getsockname(int sockfd, struct sockaddr *restrict addr,
                       socklen_t *restrict alenp);

       /**
        ,* @brief      find out the peer's address
        ,*
        ,* @return     0 if OK, -1 on error
        ,*/
       int getpeername(int sockfd, struct sockaddr *restrict addr,
                       socklen_t *restrict alenp);
     #+end_src

*** DONE 16.4 Connection Establishment
    CLOSED: [2020-01-22 Wed 10:17]
    #+begin_src c
      #include <sys/socket.h>

      /**
       ,* @brief      create a connection
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int connect(int sockfd, const struct sockaddr *addr, socklen_t len);
    #+end_src

    - Example

      #+caption: Figure 16.10 Connect with retry
      #+include: "Chapter16/16fig10.c" src c

      #+caption: Figure 16.11 Portable connect with retry
      #+include: "Chapter16/16fig11.c" src c

    #+begin_src c
      #include <sys/socket.h>

      /**
       ,* @brief      be willing to accept connect requests
       ,*
       ,* @param      backlog    a hint to the system regarding the number of
       ,*                        outstanding connect requests that it should
       ,*                        enqueue on behalf of the process.
       ,*                        is determined by the system,
       ,*                        upper limit SOMAXCONN
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int listen(int sockfd, int backlog);

      /**
       ,* @brief      retrieve a connect request and convert it into a connection
       ,*
       ,* @details
       ,*
       ,* @param      addr       set to NULL when don't care, otherwise, set a buffer
       ,*                        large enough to hold the address will be returned
       ,* @param      len        set to NULL when don't care, otherwise, set a integer
       ,*                        pointed by len and to the size of the buffer.
       ,*
       ,* @return     file (socket) descriptor if OK, -1 on error
       ,*/
      int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict len);
    #+end_src

    - Example

      #+caption: Figure 16.12 Initialize a socket endpoint for use by a server
      #+include: "Chapter16/16fig12.c" src c

*** DONE 16.5 Data Transfer
    CLOSED: [2020-01-23 Thu 18:34]
    #+begin_src c
      #include <sys/socket.h>

      /**
       ,* @brief      similar to send
       ,*
       ,* @details    allows us to specify flags to change how the data we want to
       ,* transmit is treated
       ,*
       ,* @param      flags        see below
       ,*
       ,* @return     number of bytes sent if OK, -1 on error
       ,*/
      ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);

      /**
       ,* @brief      similar to send
       ,*
       ,* @details    allows us to specify a destination address to be used with
       ,* connectionless sockets
       ,*
       ,* @return     number of bytes sent if OK, -1 on error
       ,*/
      ssize_t sendto(int sockfd, const void *buf, size_t nytes, int flags,
                     const struct sockaddr *destaddr, socklen_t destlen);

      /**
       ,* @brief      similar to writev
       ,*
       ,* @details    send multiple buffers
       ,*
       ,* @param      msghdr       specify multiple buffers from which to transmit data
       ,*
       ,* @return     number of bytes sent if OK, -1 on error
       ,*/
      struct msghdr {
              void *        msg_name;        // optional address
              socklen_t     msg_namelen;     // address size in bytes
              struct iovec *msg_iov;         // array of I/O buffers
              int           msg_iovlen;      // number of elements in array
              void *        msg_control;     // ancillary data
              socklen_t     msg_controllen;  // number of ancillary bytes
              int           msg_flags;       // flags for received message
              ...
      };
      ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
    #+end_src
    #+caption: Figure 16.13 Flags used with ~send~ socket calls
    | Flags         | Description                                                       | POSIX.1 | FreeBSD | Linux | Mac OS X | Solaris |
    |               |                                                                   |         | 8.0     | 3.2.0 | 10.6.8   | 10      |
    |---------------+-------------------------------------------------------------------+---------+---------+-------+----------+---------|
    |               | <10>                                                              |         |         |       |          |         |
    | MSG_CONFIRM   | Provide feedback to the link layer to keep address mapping valid  |         |         | *     |          |         |
    | MSG_DONTROUTE | Don't route packet outside of local network                       |         | *       | *     | *        | *       |
    | MSG_DONTWAIT  | Enable nonblocking operation (equivalent to using O_NONBLOCK)     |         | *       | *     | *        | *       |
    | MSG_EOF       | Shut the sender side of the socket down after sending data        |         | *       |       | *        |         |
    | MSG_EOR       | Mark the end of the record if supported by protocol               | *       | *       | *     | *        | *       |
    | MSG_MORE      | Delay sending the packet to allow more data to be written         |         |         | *     |          |         |
    | MSG_NOSIGNAL  | Don't generate SIGPIPE when writing to an unconnected socket      | *       | *       | *     |          |         |
    | MSG_OOB       | Send out-of-band data if supported by protocol (see Section 16.7) | *       | *       | *     | *        | *       |

    #+begin_src c
      #include <sys/socket.h>

      /**
       ,* @brief      similar to send, but fetch data
       ,*
       ,* @return     length of message in bytes, 0 if no messages are available and
       ,*             peer has done an olderly shutdown or -1 on error
       ,*/
      ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);

      /**
       ,* @brief      similar to sendto, but fetch data
       ,*
       ,* @return     length of message in bytes, 0 if no messages are available and
       ,*             peer has done an olderly shutdown or -1 on error
       ,*/
      ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags,
                       struct sockaddr *restrict addr, socklen_t *restrict addrlen);

      /**
       ,* @brief      similar to sendmsg, but fetch data
       ,*
       ,* @param      flags    see below
       ,*
       ,* @return     length of message in bytes, 0 if no messages are available and
       ,*             peer has done an olderly shutdown or -1 on error
       ,*/
      ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

    #+end_src
    #+caption: Figure 16.13 Flags used with recv socket calls
    | Flag             | Description                         | POSIX.1 | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris |
    |------------------+-------------------------------------+---------+-------------+-------------+-----------------+---------|
    | MSG_CMSG_CLOEXEC | Set the close-on-exec flag for file |         |             | *           |                 |         |
    |                  | descriptors received over a         |         |             |             |                 |         |
    |                  | UNIX domain socket                  |         |             |             |                 |         |
    |                  | (see Section 17.4)                  |         |             |             |                 |         |
    | MSG_DONTWAIT     | Enable nonblocking operation        |         | *           | *           |                 | *       |
    |                  | (equivalent to using =O_NONBLOCK=)  |         |             |             |                 |         |
    | MSG_ERRQUEUE     | Receive error information as        |         |             | *           |                 |         |
    |                  | ancillary data                      |         |             |             |                 |         |
    | MSG_OOB          | Retrieve out-of-band data if        | *       | *           | *           | *               | *       |
    |                  | supported by protocol               |         |             |             |                 |         |
    |                  | (see Section 16.7)                  |         |             |             |                 |         |
    | MSG_PEEK         | Return pack contents without        | *       | *           | *           | *               | *       |
    |                  | consuming the packet                |         |             |             |                 |         |
    | MSG_TRUNC        | Request that the real length of     |         |             | *           |                 |         |
    |                  | the packet be returned, even if     |         |             |             |                 |         |
    |                  | it was truncated                    |         |             |             |                 |         |
    | MSG_WAITALL      | Wait until all data is available    | *       | *           | *           | *               | *       |
    |                  | (SOCK_STREM only)                   |         |             |             |                 |         |

    #+caption: Figure 16.15 Flags returned in msg_flags by recvmsg
    | Flags        | Description                                      | POSIX.1 | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
    |--------------+--------------------------------------------------+---------+-------------+-------------+-----------------+------------|
    | MSG_CTRUNC   | Control data was truncated                       | *       | *           | *           | *               | *          |
    | MSG_EOR      | End of record was received                       | *       | *           | *           | *               | *          |
    | MSG_ERRQUEUE | Error information was received as ancillary data |         |             | *           |                 |            |
    | MSG_OOB      | Out-of-band data was received                    | *       | *           | *           | *               | *          |
    | MSG_TRUNC    | Normal data was truncated                        | *       | *           | *           | *               | *          |

    - Example -- Connection-Oriented Client

      #+caption: Figure 16.16 Client command to get uptime from server
      #+include: "Chapter16/16fig16.c" src c

    - Example -- Connection-Oriented Server

      #+caption: Figure 16.17 Server program to provide system uptime
      #+include: "Chapter16/16fig17.c" src c

    - Example -- Alternative Connection-Oriented Server

      #+caption: Figure 16.18 Server program illustrating command writing directly to socket

*** DONE 16.6 Socket Options
    CLOSED: [2020-01-23 Thu 15:02]
    #+begin_quote
    three kinds of options:
    1. Generic options that work with all socket types.
    2. Options that are managed at the socket leve, but depend on the underlying protocols for support
    3. Protocol-specific options unique to each individual protocol
    #+end_quote

    #+begin_src c

      #include <sys/socket.h>

      /**
       ,* @brief      set a socket option
       ,*
       ,* @param      option     see below
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int setsockopt(int sockfd, int level, int option, const void *val,
                     socklen_t len);

      /**
       ,* @brief      get a socket option
       ,*
       ,* @param      option     see below
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int getsockopt(int sockfd, int level, int option, void *val,
                     socklen_t *restrict lenp);
    #+end_src
    #+caption: Figure 16.21 Socket options
    | Option        | Type of val argument | Description                                                         |
    |---------------+----------------------+---------------------------------------------------------------------|
    | SO_ACCEPTCONN | int                  | Return whether a socket is enabled for listening (getsockopt only). |
    | SO_BROADCAST  | int                  | Broadcast datagrams if *val is nonzero.                             |
    | SO_DEBUG      | int                  | Debugging in network drivers enabled if *val is nonzero.            |
    | SO_DONTROUTE  | int                  | Bypass normal routing if *val is nonzero.                           |
    | SO_ERROR      | int                  | Return and clear pending socket eror (getsockopt only).             |
    | SO_KEEPALIVE  | int                  | Periordic keep-alive messages enabled if *val is nonzero.           |
    | SO_LINGER     | struct linger        | Delay time when unsent messages exist and socket is closed.         |
    | SO_OOBINLINE  | int                  | Out-of-band data placed inline with normal data if *val is nonzero. |
    | SO_RCVBUF     | int                  | The size in bytes of the receive buffer.                            |
    | SO_RCVLOWAT   | int                  | The minimum amount of data in bytes to return on a receive call.    |
    | SO_RCVTIMEO   | struct timeval       | The timeout value for a socket receive call.                        |
    | SO_REUSEADDR  | int                  | Reuse addresses in bind if *val is nonzero.                         |
    | SO_SNDBUF     | int                  | The size in bytes of the send buffre.                               |
    | SO_SNDLOWAT   | int                  | The minium amount of data in bytes to transmit in a send call.      |
    | SO_SNDTIMEO   | struct timeval       | The timeout value for a socket send call.                           |
    | SO_TYPE       | int                  | Identify the socket type (getsockopt only).                         |

    - Example

      #+caption: Figure 16.22 Initialize a socket endpoint for use by a server with address reuse
      #+include: "Chapter16/16fig22.c" src c

*** DONE 16.7 Out-of-Band Data
    CLOSED: [2020-01-23 Thu 15:42]
    allowing higher-priority delivery of data than normal.
    is sent ahead of any data that is already queued for transmission.

    TCP refers to out-of-band data as "urgent" data. TCP supports only a single byte of urgent data,
    but allows urgent data to be delivered out of band from the normal data delivery mechanisms.
    specify =MSG_OOB= flag to ~send~ functions.
    with more than one byte with =MSG_OOB= flag, the last byte will be treated as the urgent-data byte.

    sent =SIGURG= signal when urgent data is received and we have arranged for signal generation by the socket.

    receive signals from a socket by calling
    #+begin_src c
      /**
       ,* @brief      receive signals from a socket
       ,*
       ,* @details
       ,*
       ,* @param      F_SETOWN   be used to retrieve the current socket ownership
       ,* @parm       pid        a positive value represents a process ID
       ,*/
      int pid = fcntl(sockfd, F_GETOWN, 0);
      fcntl(sockfd, F_SETOWN, pid);
    #+end_src

    /urgent mark/: the point in the normal data stream where the urgent data would go.

    receive the urgent data inline with the normal data: =SO_OOBINLINE=

    identify when we have reached the urgent mark
    #+begin_src c
      #include <sys/socket.h>

      /**
       ,* @brief      identify the urgent mark
       ,*
       ,* @return     1 if at mark, 0 if not at mark, -1 on error
       ,*/
      int sockatmark(int sockfd);
    #+end_src

*** DONE 16.8 Nonblocking and Asynchronous I/O
    CLOSED: [2020-01-23 Thu 15:58]
    normally, I/O functions will block when it is not immediately available.

    when the socket is in nonblocking mode, these function failes instead of blocking, setting =errno= to either =EWOULDBLOCK= or =EAGAIN=. we can use either ~poll~ or ~select~ to determine when we can receive or transmit data.

    with socket-based asynchronous I/O, sent =SIGIO= signal when it's available.

    Enabling asynchronous I/O:
    1. Establish socket ownership so signals can be delivered to the proper progresses.

       - Use the =F_SETOWN= command with ~fcntl~.

       - Use the =FIOSETOWN= command with ~ioctl~.

       - Use the =SIOCSPGRP= command with ~ioctl~.

    2. Inform the socket that we want it to signal us when I/O operations won't block.

       - Use the =F_SETFL= command with ~fcntl~ and enable the =O_ASYNC= file flag.

       - Use the =FIOASYNC= command with ~ioctl~.

    #+caption: Figure 16.23 Socket asynchronous I/O management commands
    | Mechanism                               | POSIX.1 | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
    |-----------------------------------------+---------+-------------+-------------+-----------------+------------|
    | fcntl(fd, F_SETOWN, pid)                | *       | *           | *           | *               | *          |
    | ioctl(fd, FIOSETOWN, pid)               |         | *           | *           | *               | *          |
    | ioctl(fd, SIOCSPGRP, pid)               |         | *           | *           | *               | *          |
    |-----------------------------------------+---------+-------------+-------------+-----------------+------------|
    | fcntl(fd, F_SETFL, flags \vert O_ASYNC) |         | *           | *           | *               |            |
    | ioctl(fd, FIOASYNC, &n);                |         | *           | *           | *               | *          |

*** DONE 16.9 Summary
    CLOSED: [2020-01-31 Fri 14:51]

    - Example

      - 16.1 see below

        #+include: "Chapter16/16ex01.cpp" src cpp

      - 16.2 see below

        | Fields                         | Mac OS X 10.15.2 | Linux 3.10 |
        |--------------------------------+------------------+------------|
        | ID of device containing file   |                0 |          7 |
        | Mode of file (see below)       |            49590 |      49663 |
        | Number of hard links           |                0 |          1 |
        | File serial number             |                0 |      58400 |
        | User ID of the file            |              501 |    0(root) |
        | Group ID of the file           |               20 |    0(root) |
        | Device ID                      |                0 |          0 |
        | time of last access            |                0 |          0 |
        | time of last data modification |                0 |          0 |
        | time of last status change     |                0 |          0 |
        | time of file creation(birth)   |                0 |            |
        | user defined flags for file    |                0 |            |
        | file generation number         |                0 |            |
        | file size, in bytes            |                0 |          0 |
        | blocks allocated for file      |                0 |          0 |
        | optimal blocksize for I/O      |           131072 |       4096 |
        |--------------------------------+------------------+------------|
        #+include: "Chapter16/16ex02.cpp" src cpp

      - 16.3 *NEED TO BE TESTED*

        #+include: "Chapter16/16ex03.c" src c

      - 16.4 see below for server program

        #+include: "Chapter16/16ex04s.c" src c

      - 16.5

        #+include: "Chapter16/16ex05.c" src c

      - 16.6

        #+include: "Chapter16/16ex06.c" src c

** TODO Chapter 17. Advanced IPC [3/7]
*** DONE 17.1 Introduction
    CLOSED: [2020-02-01 Sat 18:02]

*** DONE 17.2 UNIX Domain Sockets
    UNIX domain sockts are used to communicate with processes running on the same machines.

    #+begin_src c
      #include <sys/socket.h>

      /**
       ,*  @brief create a pair of unamed, connected, UNIX domain sockets.
       ,*
       ,*  @return 0 if OK, -1 on error
       ,*/
      int socketpair(int domain, int type, int protocol, int sockfd[2]);
    #+end_src

    #+caption: Figure 17.1 A socket pair
    [[file:Chapter17/17fig01.jpg]]

    - Example -- fd_pipe Functions

      #+caption: Figure 17.2 Creating a full-duplex pipe
      #+include: "Chapter17/17fig02.c" src c

    - Example -- Polling XSI Message Queues with the Help of UNIX Domain Sockets

      #+caption: Figure 17.3 Poll for XSI Messsages using UNIX domain sockets
      #+include: "Chapter17/17fig03.c" src c

      #+caption: Figure 17.4 Post a message to XSI message queue
      #+include: "Chapter17/17fig04.c" src c

**** DONE 17.2.1 Naming UNIX Domain Sockets
     Unamed socket pairs can't be addressed by unrelated processes.
     #+begin_src c
       /**
        ,* @brief      UNIX domain socket on Linux 3.2.0 and Solaris 10,
        ,*  *             defined in <sys/un.h>
        ,*/
       struct sockaddr_un {
               sa_family_t sun_family;     // AF_UNIX
               char        sun_path[108];  // pathname
       };

       /**
        ,* @brief      UNIX domain socket on FreeBSD 8.0 and Mac OS X 10.6.8
        ,*/

       struct sockaddr_un {
               unsigned char sun_len;        // sockaddr length
               sa_family_t   sun_family;     // AF_UNIX
               char          sun_path[104];  // pathname
       };
     #+end_src

     - Example

       #+caption: Figure 17.5 Binding an address to a UNIX domain socket
       #+include: "Chapter17/17fig05.c" src c

*** DONE 17.3 Unique Connections
    CLOSED: [2020-02-01 Sat 18:04]
    #+caption: Figure 17.6 Client and server sockets before a ~connect~
    [[file:Chapter17/17fig06.jpg]]

    #+caption: Figure 17.7 Client and server sockets after a ~connect~
    [[file:Chapter17/17fig07.jpg]]

    develop three functions can be used to create unique connections between unrelated processes running on same machine:
    #+begin_src c
      // @return: file descriptor to listen on if OK, negative value on error
      int serv_listen(const char *name);
      // @return: new file descriptor if OK, negative value on Error
      int serv_accept(int listenfd, uid_t *uidptr);
      // @return: file descriptor if OK, negative value on error
      int cli_conn(const char *name);
    #+end_src

    #+caption: Figure 17.8 The ~serv_listen~ function
    #+include: "Chapter17/17fig08.c" src c

    #+caption: Figure 17.9 The ~serv_accept~ function
    #+include: "Chapter17/17fig09.c" src c

    #+caption: Figure 17.10 The ~cli_conn~ function
    #+include: "Chapter17/17fig10.c" src c

*** TODO 17.4 Passing File Descriptors
    #+begin_quote
    It can lead to different ways of designing client-server applications.
    It allows one process (typically a server) to do everything that is required to open a file
    (involving such details as translating a network name to a network address, dialing a modem, and neogiating
    locks for the file) and simply pass back to the calling process a descriptor that can be used with all the I/O functions.
    #+end_quote

    #+caption: Figure 17.11 Passing an open file from the top process to the bottom process
    [[file:Chapter17/17fig11.jpg]]

    #+begin_src c
      #include "apue.h"

      /**
       ,* @brief       send file descriptor
       ,*
       ,* @detail      sends the descriptor fd_to_send across
       ,* using the UNIX domain socket represented by fd.
       ,*
       ,* @return      0 if OK, -1 on error
       ,*/
      int send_fd(int fd, int fd_to_send);

      /**
       ,* @brief      send file descriptor
       ,*
       ,* @detail     sends the errmsg using fd, followed by
       ,* the status byte. The value of status must be in the
       ,* range -1 through -255.
       ,*
       ,* @return     0 if OK, -1 on error
       ,*/
      int send_err(int fd, int status, const char *errmsg);

      /**
       ,* @brief     receive file descriptor
       ,*
       ,* @detail    if error, the value returned is the status
       ,* that was sent by send_err (a negative value in the range -1 through -255).
       ,*
       ,* @param     userfunc  process the message (often was write)
       ,* @param     1st     STDERR_FILENO
       ,* @param     2nd     a pointer to the e rror message
       ,* @param     3st     length of message
       ,* @return    number of bytes written or a negative number on error.
       ,*
       ,* @return    the file descriptor if OK, negative value on error
       ,*/
      int recv_fd(int fd, sszie_t (*userfunc)(int, const void *, size_t));
    #+end_src

    #+caption: Figure 17.12 The ~send_err~ function
    #+include: "Chapter17/17fig12.c" src c

    call sendmsg and recvmsg functions to take a pointer to ~msghdr~ strcture to exchange file descriptors using UNIX domain sockets
    #+begin_src c
      struct msghdr {
              void *        msg_name;     // optional address
              socklen_t     msg_namelen;  // address size in bytes
              struct iovec *msg_iov;      // array of I/O buffers
              int           msg_iovlen;   // number of elements in array
              void *        msg_control;  // ancillary adata
              int           msg_flags;    // flags for received message
      };

      struct cmsghdr {
              socklen_t cmsg_len;    // data byte count, including header
              int       cmsg_level;  // originating protocol
              int       cmsg_type;   // protocol-specific type
              // followed by the actual control message data
      };

      #include <sys/socket.h>

      /**
       ,* access the control data
       ,* @return  pointer to data associated with cmsghdr structure
       ,*/
      unsigned char *CMSG_DATA(struct cmsghdr *cp);

      /**
       ,* @return pointer to first cmsghdr structure associated with
       ,*         the msghdr structure, or NULL if none exists
       ,*/
      struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *mp);

      /**
       ,* @return pointer to next cmsghdr structure assocaited with
       ,*         the msghdr structure given the current cmsghdr
       ,*         structure, or NULL if we're at the last one
       ,*/
      struct cmsghdr *CMSG_NXTHDR(struct msghdr *mp, struct cmsghdr *cp);

      /**
       ,* @breif     get the value to be used
       ,* @return    size to allocate for data object nbytes large
       ,* @note      The Single UNIX Specification defines the first three macros, but
       ,* omits CMSG_LEN.
       ,*/
      unsigned int CMSG_LEN(unsigned int nbytes);
    #+end_src

*** TODO 17.5 An Open Server, Version 1
*** TODO 17.6 An Open Server, Version 2
*** TODO 17.7 Summary
** TODO Chapter 18. Terminal I/O [0/0]
*** 18.1 Introduction
*** 18.2
** TODO Chapter 19. Pseudo Terminals [0/0]
** TODO Chapter 20. A Database Library [0/0]
** TODO Chapter 21. Communication with a Network Printer [0/0]
* Footnotes
[fn:1] ~signalstack~
